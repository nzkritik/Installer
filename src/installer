#!/usr/bin/env bash
# vim:ft=sh:fdm=marker:fmr={,}

# Originally Written by Carl Duff for PacBang Linux
# Heavily modified by Nathaniel Maia for use in Archlabs
# This program is free software, provided under the GNU GPL

LUSER="liveuser"    # Live user
DIST="Archlabs"     # Distributor
VER="1.4.6"         # Version
MNT="/mnt/install"  # Mountpoint
ANS="/tmp/answer"   # Stores answers
MOPTS="/tmp/mopts"  # Mount options
ERR="/tmp/errlog"   # Error logging
LOG="/tmp/log"      # set -x logging
EFI_MNT="boot/efi"  # EFI mountpoint
VG_MB=0             # Remaining VG MB
SBOOT=0             # Separate /boot
HOOKS="shutdown"    # Init hooks

# geolocation timezone used for automatic setup
GEOLC="$(curl --silent freegeoip.net/xml/)"
GEOLC="${GEOLC#*<TimeZone>}"
GEOLC="${GEOLC%</TimeZone>*}"

# timezones used for manual setup if automatic fails
TZONES="$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab | grep ".*/.*" | sort -ud)"
for i in $(awk -F/ '{print $1}' <<< "$TZONES"); do
    ZONES="$ZONES $i -"
done

# parsed locales from /etc/locale.gen
LOCALES="$(grep -v "# " /etc/locale.gen | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8)"
for i in $LOCALES; do
    LCLS="$LCLS $i -"
done

# parsed console maps from /usr/share/kbd/keymaps
CMAPS="$(ls -R /usr/share/kbd/keymaps | grep "map.gz" | sed 's/\.map\.gz//g' | sort)"
for i in $CMAPS; do
    CMAP="$CMAP $i -"
done

# array of keymaps for use with xorg
XMAPS=('af' 'al' 'am' 'at' 'az' 'ba' 'bd' 'be' 'bg' 'br' 'bt' 'bw' 'by' 'ca'
'cd' 'ch' 'cm' 'cn' 'cz' 'de' 'dk' 'ee' 'es' 'et' 'eu' 'fi' 'fo' 'fr' 'gb' 'ge'
'gh' 'gn' 'gr' 'hr' 'hu' 'ie' 'il' 'in' 'iq' 'ir' 'is' 'it' 'jp' 'ke' 'kg' 'kh'
'kr' 'kz' 'la' 'lk' 'lt' 'lv' 'ma' 'md' 'me' 'mk' 'ml' 'mm' 'mn' 'mt' 'mv' 'ng'
'nl' 'no' 'np' 'pc' 'ph' 'pk' 'pl' 'pt' 'ro' 'rs' 'ru' 'se' 'si' 'sk' 'sn' 'sy'
'tg' 'th' 'tj' 'tm' 'tr' 'tw' 'tz' 'ua' 'us' 'uz' 'vn' 'za')
for i in "${XMAPS[@]}"; do
    XMAP="$XMAP $i -"
done

######################################################################
##                  Utility and Check Functions                     ##
######################################################################

chr() {
    arch-chroot $MNT /bin/bash -c "$1"
}

debug_log() {
    echo "" >$LOG
    set -x
    exec 3>| $LOG
    BASH_XTRACEFD=3
    ( termite --exec="tail -f $LOG" & )
}

select_lang() {
    dialog --backtitle "$BT" --title " Select Language " --menu \
        "Language - sprache - taal - språk - lingua - idioma - nyelv - língua" 20 60 9 \
        "1" "English            (en_**)" "2" "Español            (es_ES)" \
        "3" "Português [Brasil] (pt_BR)" "4" "Português          (pt_PT)" \
        "5" "Français           (fr_FR)" "6" "Russkiy            (ru_RU)" \
        "7" "Italiano           (it_IT)" "8" "Nederlands         (nl_NL)" \
        "9" "Magyar             (hu_HU)" 2> $ANS
    case "$(cat $ANS)" in
        1) . /installer/english.trans ; LOC="en_US.UTF-8" ;;
        2) . /installer/spanish.trans ; LOC="es_ES.UTF-8" ;;
        3) . /installer/p_brasil.trans ; LOC="pt_BR.UTF-8" ;;
        4) . /installer/portuguese.trans ; LOC="pt_PT.UTF-8" ;;
        5) . /installer/french.trans ; LOC="fr_FR.UTF-8" ;;
        6) . /installer/russian.trans ; LOC="ru_RU.UTF-8" ;;
        7) . /installer/italian.trans ; LOC="it_IT.UTF-8" ;;
        8) . /installer/dutch.trans ; LOC="nl_NL.UTF-8" ;;
        9) . /installer/hungarian.trans ; LOC="hu_HU.UTF-8" ;;
        *) clear && exit 0
    esac
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
    [[ $LOC != "en_US.UTF-8" ]] && sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG="$LOC"
}

check_req() {
    if [[ $(whoami) != "root" ]] || ! ping -c 1 google.com &>/dev/null; then
        [[ $(whoami) != "root" ]] && msg="$_RtFailBody" || msg="$_ConFailBody"
        dialog --backtitle "$BT" --title " $_ErrTitle " --infobox "$msg" 0 0
        sleep 3 && clear && exit 1
    fi
    echo "" > $ERR
}

id_system() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi
    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYSTEM="UEFI"
    else
        SYSTEM="BIOS"
    fi
    BT="$DIST Installer - $SYSTEM (x86_64)"
}

check_errors() {
    if (( $? == 1 )) && grep -wqi "${errmsg:-error}" "$ERR"; then
        local msg
        msg="$(sed 's/[^[:print:]]//g' "$ERR" | sed 's/\[[0-9\;:]*\?m//g' | sed 's/==> //g' | sed 's/] ERROR:/]\nERROR:/g')"
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$msg" 0 0
        msg="An error was encountered during install\n\n'Yes' to keep install"
        msg="$msg intact and fix manually\n'No' to wipe install (preserves /boot)"
        if ! dialog --backtitle "$BT" --title " $_ErrTitle " --yesno "$msg" 9 55; then
            for d in $MNT/?*; do
                ! grep -q "boot" <<<"$d" && rm -rf $d || continue
            done
        fi
        echo "" >$ERR # wipe error log
        return 1
    fi
    return 0
}

check_mount() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        return 1
    fi
    return 0
}

check_base() {
    if ! [[ -e $MNT/etc ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        return 1
    fi
    return 0
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT | grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dialog --backtitle "$BT" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

######################################################################
##                  System Settings Functions                       ##
######################################################################

set_keymap() {
    set_console_keymap() {
        local msg ttl map
        msg="$_VCKeymapBody" ttl=" $_VCKeymapTitle "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 22 60 16 $CMAP 2>$ANS || return 1
        map="$(cat $ANS)"
        map=${map:-us}
        echo "KEYMAP=$map" >/tmp/vconsole.conf
    }

    set_xorg_keymap() {
        local msg ttl map
        msg="$_XkbmapBody"
        ttl=" $_PrepKBLayout "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 22 60 16 $XMAP 2>$ANS || return 1
        map="$(sed 's/_.*//' $ANS)"
        map="${map:-us}"
        setxkbmap "$map" 2>$ERR
        check_errors || return 1
        cat >/tmp/01-keyboard.conf <<EOF
Section "InputClass"
    Identifier "system-keyboard"
    MatchIsKeyboard "on"
    Option "XkbLayout" "$map"
EndSection
EOF
        cat >/tmp/keyboard <<EOF
# KEYBOARD CONFIGURATION FILE
# Consult the keyboard(5) manual page.

XKBMODEL=""
XKBLAYOUT="$map"
XKBVARIANT=""
XKBOPTIONS=""
BACKSPACE="guess"
EOF
    }
    set_console_keymap && set_xorg_keymap || return 1
}

set_locale() {
    local ttl=" $_ConfBseSysLoc "
    local msg="$_localeBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 20 60 12 $LCLS 2>$ANS || return
    loc="$(cat $ANS)"
    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/locale.conf
    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/g" $MNT/etc/locale.gen
    sed -i "s/#${loc}/${loc}/g" $MNT/etc/locale.gen
    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/default/locale
    dialog --backtitle "$BT" --title "$ttl" --infobox "\nGenerating locale for: $loc\n$_PlsWaitBody" 0 0
    sleep 1
    chr "locale-gen" >/dev/null 2>$ERR
    check_errors || return 1
    set_timezone
}

set_timezone() {
    local zone sub local ttl msg
    if [[ -z $manual ]]; then
        if grep -q "$GEOLC" <<< "$TZONES"; then
            zone="${GEOLC%/*}"
            sub="${GEOLC#*/}"
        fi
    else
        ttl=" $_ConfBseTimeHC "
        msg="$_TimeZBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 20 45 10 $ZONES 2>$ANS || return
        zone="$(cat $ANS)"
        for i in $(grep "$zone" <<< "$TZONES" | awk -F/ '{print $2}' | sort -ud); do
            SUBS="$SUBS $i -"
        done
        msg="$_TimeSubZBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 20 45 11 $SUBS 2>$ANS || return
        sub="$(cat $ANS)"
    fi

    if [[ ! -z $zone && ! -z $sub ]]; then
        ttl=" $_ConfBseTimeHC "
        msg="$_TimeZQ $zone/$sub?\n\n"
        if dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
            chr "ln -sf /usr/share/zoneinfo/$zone/$sub /etc/localtime" 2>$ERR
            check_errors || return 1
        else
            manual="True"
            set_timezone
        fi
    else
        manual="True"
        set_timezone
    fi
    SETT="True"
    set_hw_clock
}

set_hw_clock() {
    chr "hwclock --systohc --utc"
    if (( $? == 1 )); then
        chr "hwclock --systohc --utc --directisa" 2>$ERR
        if (( $? == 1 )) && grep -wqi "error" "$ERR"; then
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$(cat "$ERR")" 0 0
            echo "" >$ERR
        fi
    fi
}

set_hostname() {
    local host ttl msg
    host=${DIST,,}
    ttl=" $_ConfBseHost "
    msg="$_HostNameBody"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 14 60 "$host" 2>$ANS || return 1
    host="$(cat $ANS)"
    echo "$host" >$MNT/etc/hostname
    cat >$MNT/etc/hosts <<EOF
127.0.0.1   localhost
127.0.1.1   $host
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF
}

root_password() {
    local ttl=" $_ConfUsrRoot "
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$_PassRtBody" 8 40 2>$ANS || return 1
    PASSWD="$(cat $ANS)"
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$_PassRtBody2" 8 40 2>$ANS || return 1
    PASSWD2="$(cat $ANS)"
    if [[ "$PASSWD" == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        chr "passwd root" </tmp/.passwd >/dev/null 2>$ERR
        rm -f /tmp/.passwd
        check_errors || return 1
        RPASS="True"
        return 0
    fi
    dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
    root_password
}

create_user() {
    dialog --backtitle "$BT" --title " $_NUsrTitle " --inputbox "$_NUsrBody" 10 40 "" 2>$ANS || return 1
    usr="$(cat $ANS)"
    while [[ ${#usr} -eq 0 || $usr =~ \ |\' || $usr =~ [^a-z0-9\ ] ]]; do
        dialog --backtitle "$BT" --title " $_NUsrTitle " --inputbox "$_NUsrErrBody" 10 40 "" 2>$ANS || { break; return 1; }
        usr="$(cat $ANS)"
    done
    local msg1="$_PassNUsrBody $usr"
    local msg2="$_PassNUsrBody2 $usr"
    local ttl=" $_ConfUsrNew "
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg1" 8 40 2>$ANS || return 1
    PASSWD="$(cat $ANS)"
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg2" 8 40 2>$ANS || return 1
    PASSWD2="$(cat $ANS)"
    while [[ "$PASSWD" != "$PASSWD2" ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 8 60
        dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg1" 8 40 2>$ANS || { break; return 1; }
        PASSWD="$(cat $ANS)"
        dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg2" 8 40 2>$ANS || { break; return 1; }
        PASSWD2="$(cat $ANS)"
    done
    dialog --backtitle "$BT" --title "$ttl" --infobox "$_NUsrSetBody" 0 0
    sleep 2 && echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
    local group="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"

    # If the first user account, change the live account
    if [[ -e $MNT/home/$LUSER ]]; then
        chr "passwd $LUSER" </tmp/.passwd >/dev/null 2>$ERR
        check_errors || return 1
        local files wheel autostart
        wheel="%wheel ALL=(ALL) ALL"
        autostart="home/$LUSER/.config/openbox/autostart"
        files=(etc/systemd/system/autologin@.service $autostart etc/group etc/gshadow etc/passwd etc/shadow)
        for f in "${files[@]}"; do sed -i "s/${LUSER}/${usr}/g" "$MNT/$f"; done
        chr "mv /home/$LUSER /home/$usr" 2>$ERR
        chr "chown -R $usr:users /home/$usr" 2>>$ERR
        chr "usermod -aG $group $usr" 2>>$ERR
        sed -i "s/# ${wheel}/${wheel}/g" $MNT/etc/sudoers
    else
        chr "useradd $usr -m -g users -G $group -s /bin/zsh" 2>$ERR
        chr "passwd $usr" < /tmp/.passwd >/dev/null 2>>$ERR
        chr "cp -R /etc/skel/ /home/$usr" 2>>$ERR
        chr "chown -R ${usr}:users /home/$usr" 2>>$ERR
    fi
    check_errors || return 1

    [[ -e /tmp/.passwd ]] && rm /tmp/.passwd
    [[ -z $UNPCK || -z $SETT || -z $RPASS || -z $BOOTD ]] && return 0
    ttl="Installation Finished"
    msg="The install is now complete\n\nWould you like to close the installer and reboot\n\nSelect 'No' to make additional changes to the system"
    dialog --backtitle "$BT" --title " $ttl " --yesno "$msg" 0 0 && { umount_parts; reboot; } || return 1
}

######################################################################
##                System and Partitioning Functions                 ##
######################################################################

umount_parts() {
    MOUNTED="$(mount | grep "$MNT" | awk '{print $3}' | sort -r)"
    swapoff -a
    for i in $MOUNTED; do
        umount -r "$i" >/dev/null 2>$ERR
        check_errors || return 1
    done
}

confirm_mount() {
    local ttl msg
    ttl=" $_MntStatusTitle "
    if grep -q "$1" <<< "$(mount)"; then
        dialog --backtitle "$BT" --title "$ttl" --infobox "$_MntStatusSucc" 0 0
        sleep 2
        PARTS="$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS" | sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PART}$' -'~~)"
        ((NUM--))
        return 0
    fi
    dialog --backtitle "$BT" --title "$ttl" --infobox "$_MntStatusFail" 0 0
    sleep 2
    return 1
}

select_device() {
    local msg
    DEVICE=""
    [[ $1 == "grub" ]] && msg="$_DevSelTitle for Bootloader\n\n$_DevSelBody" || msg="$_DevSelBody"
    DEVS="$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u)"
    dialog --backtitle "$BT" --title " $_DevSelTitle " --menu "$msg" 0 0 4 $DEVS 2>$ANS || return 1
    [[ $(cat $ANS) != "" ]] && DEVICE="$(cat $ANS)" || return 1
}

find_parts() {
    PARTS=""
    NUM=0
    LBLK="$(lsblk -lno NAME,SIZE,TYPE | grep "$INC_PART" | sed 's/part$/\/dev\//g')"
    LBLK="$(sed 's/lvm$\|crypt$/\/dev\/mapper\//g' <<< "$LBLK")"
    PARTS="$(awk '{print $3$1 " " $2}' <<< "$LBLK" | sort -u)"
    for i in $PARTS; do ((NUM++)); done
    NUM=$((NUM / 2))
    case "$INC_PART" in
        'part\|lvm\|crypt') [[ $NUM -eq 0 || ($SYSTEM == "UEFI" && $NUM -lt 2) ]] && ERRMSG="$_PartErrBody" ;;
        'part\|crypt') (( NUM == 0 )) && ERRMSG="$_LvmPartErrBody" ;;
        'part\|lvm') (( NUM < 2 )) && ERRMSG="$_LuksPartErrBody"
    esac
    if [[ $ERRMSG ]]; then
        local ttl=" $_ErrTitle "
        dialog --backtitle "$BT" --title "$ttl" --msgbox "$ERRMSG" 0 0
        select_device && create_parts || return 1
    fi
    return 0
}

create_parts() {
    secure_wipe() {
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BT" --title " $_PartOptWipe " --yesno "$msg" 0 0; then
            clear ; echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            create_parts
        fi
    }

    auto_partition() {
        if [[ $SYSTEM == "BIOS" ]]; then
            _AutoPartBody2="will be destroyed.\n\nAn ext4 partition will be created using all available space."
        fi
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BT" --title " $_PrepPartDisk " --yesno "$msg" 0 0; then
            dp="$(parted -s "$DEVICE" print | awk '/^ / {print $1}' | sort -r)"
            for p in $dp; do
                parted -s "$DEVICE" rm $p 2>$ERR
                check_errors || { break; return 1; }
            done
            table="$(parted -s "$DEVICE" print | grep -i 'partition table' | awk '{print $3}')"
            if [[ $SYSTEM == "BIOS" && $table != "msdos" ]]; then
                parted -s "$DEVICE" mklabel msdos 2>$ERR
            elif [[ $SYSTEM == "UEFI" && $table != "gpt" ]]; then
                parted -s "$DEVICE" mklabel gpt 2>$ERR
            fi
            check_errors || return 1
            if [[ $SYSTEM == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 100% 2>$ERR
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>$ERR
                parted -s "$DEVICE" set 1 boot on 2>>$ERR
                parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>$ERR
            fi
            check_errors || return 1
            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist
            dialog --backtitle "$BT" --title "" --textbox /tmp/.devlist 0 0
        fi
    }
    dialog --backtitle "$BT" --title "$_PartToolTitle" --menu "$_PartToolBody" 0 0 5 \
        "$_PartOptWipe" "BIOS & UEFI" \
        "$_PartOptAuto" "BIOS & UEFI" \
        "gparted"       "BIOS & UEFI" \
        "cfdisk"        "BIOS/MBR" \
        "parted"        "UEFI/GPT" 2>$ANS
    RET="$(cat $ANS)"
    [[ -z $RET ]] && return 1
    if [[ $RET != "$_PartOptWipe" && $RET != "$_PartOptAuto" ]]; then
        $RET "$DEVICE"
    elif [[ $RET == "$_PartOptWipe" ]]; then
        secure_wipe && create_parts
    else
        auto_partition
    fi
    return 0
}

choose_fs() {
    FS_OPTS=()
    dialog --backtitle "$BT" --title " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_Skip"   "-" \
        "ext4"     "mkfs.ext4 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext2"     "mkfs.ext2 -q" \
        "btrfs"    "mkfs.btrfs -f" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2>$ANS
    select="$(cat $ANS)"
    case $select in
        "$_Skip") FS="$_Skip" ;;
        ext4) FS="mkfs.ext4 -q" FS_OPTS=(dealloc discard noacl noatime nobarrier nodelalloc) ;;
        ext3) FS="mkfs.ext3 -q" ;;
        ext2) FS="mkfs.ext2 -q" ;;
        btrfs) FS="mkfs.btrfs -f"
            FS_OPTS=(autodefrag "compress=zlib" "compress=lzo"
            "compress=no" "compress-force=zlib" "compress-force=lzo"
            discard noacl noatime nodatasum nospace_cache recovery
            skip_balance space_cache ssd ssd_spread)
            modprobe btrfs
            ;;
        f2fs) FS="mkfs.f2fs"
            FS_OPTS=(data_flush disable_roll_forward disable_ext_identify
            discard fastboot flush_merge inline_xattr inline_data inline_dentry
            no_heap noacl nobarrier noextent_cache noinline_data norecovery)
            modprobe f2fs
            ;;
        jfs) FS="mkfs.jfs -q" FS_OPTS=(discard "errors=continue" "errors=panic" nointegrity) ;;
        nilfs2) FS="mkfs.nilfs2 -q"
            FS_OPTS=(discard nobarrier "errors=continue" "errors=panic" "order=relaxed" "order=strict" norecovery)
            ;;
        ntfs) FS="mkfs.ntfs -q" ;;
        reiserfs) FS="mkfs.reiserfs -q" FS_OPTS=(acl nolog notail replayonly user_xattr) ;;
        vfat) FS="mkfs.vfat -F32" ;;
        xfs) FS="mkfs.xfs -f"
            FS_OPTS=(discard filestreams ikeep largeio noalign nobarrier norecovery noquota wsync)
            ;;
        *) return 1
    esac
    if [[ $FS != "$_Skip" ]]; then
        local msg=""
        if dialog --backtitle "$BT" --title " $_FSTitle " --yesno "\nFormat $PART as $select?\n\n" 0 0; then
            msg="\nFormatting $PART as $select.\n$_PlsWaitBody"
            dialog --backtitle "$BT" --title " $_FSTitle " --infobox "$msg" 0 0
            sleep 1
            $FS $PART >/dev/null 2>$ERR
            check_errors || return 1
        else
            choose_fs
        fi
    fi
}

mount_parts() {
    opts() {
        OPTS=""
        echo "" >$MOPTS
        local ttl msg
        for i in "${FS_OPTS[@]}"; do
            OPTS="$OPTS $i - off"
        done
        ttl=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "
        dialog --backtitle "$BT" --title "$ttl" --checklist "$_MntBody" 0 0 ${#FS_OPTS[@]} $OPTS 2>$MOPTS || return
        sed -i 's/ /,/g' $MOPTS
        sed -i '$s/,$//' $MOPTS
        MOUNT_OPTS="$(cat $MOPTS)"
        if [[ $MOUNT_OPTS ]]; then
            msg="${_MntConfBody}$MOUNT_OPTS\n"
            ttl=" $_MntStatusTitle "
            dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 10 50 && return 0 || opts
        fi
    }

    mnt() {
        local op b blk
        mkdir -p "${MNT}$MOUNT"
        (( ${#FS_OPTS[@]} > 0 )) && opts
        op="$(cat $MOPTS)"
        if [[ $op ]]; then
            mount -o $op "$PART" "${MNT}$MOUNT" 2>$ERR
        else
            mount "$PART" "${MNT}$MOUNT" 2>$ERR
        fi
        check_errors && confirm_mount "${MNT}$MOUNT" || return 1

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        b="$(lsblk -lno NAME,FSTYPE,TYPE)"
        if grep -qi "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then
            LUKS=1
            LUKS_NAME="$(sed "s~^/dev/mapper/~~g" <<< "$PART")"
            blk="$(grep "lvm" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/mapper/"$1}' <<< "$blk" | uniq)"
            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME"
                    LVM=1
                    break
                fi
            done
            blk="$(grep "part" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/"$1}' <<< "$blk" | uniq)"
            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID="$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")"
                    LUKS_UUID="$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')"
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    break
                fi
            done
        elif grep -qi "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
            LVM=1
            LV_NAME="$(sed "s~^/dev/mapper/~~g" <<< "$PART")"
            blk="$(grep "crypt" <<< "$b" | grep -i "lvm2_member")"
            crypt="$(awk '{print "/dev/mapper/"$1}' <<< "$blk" | uniq)"
            for i in $crypt; do
                if grep -q "$LV_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME="$(sed 's~/dev/mapper/~~g' <<< "$i")"
                    break
                fi
            done
            blk="$(grep "part" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/"$1}' <<< "$blk" | uniq)"
            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID="$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")"
                    LUKS_UUID="$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')"
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    LUKS=1
                    break
                fi
            done
        fi
    }

    swap() {
        local a ttl msg mem tot
        mem="$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')"
        dialog --backtitle "$BT" --title " $_PrepMntPart " --menu "$_SelSwpBody" 0 0 7 \
            "$_Skip" "-" \
            "$_SelSwpFile" "${mem}M" \
            $PARTS 2>$ANS || return 1

        a="$(cat $ANS)"
        if [[ $a && $a != "$_Skip" ]]; then
            PART="$(cat $ANS)"
            if [[ $PART == "$_SelSwpFile" ]]; then
                local ttl msg
                ttl=" $_SelSwpFile "
                msg="Enter size for swapfile below\n\nM = MB, G = GB"
                dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2>$ANS || return 0
                tot="$(cat $ANS)"
                while ! [[ ${tot: -1} =~ [MG] ]]; do
                    msg="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 7 40
                    msg="\nM = MB, G = GB\n"
                    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2>$ANS || { break; return 0; }
                    tot="$(cat $ANS)"
                done
                fallocate -l "$tot" $MNT/swapfile 2>$ERR
                chmod 600 $MNT/swapfile 2>>$ERR
                mkswap $MNT/swapfile >/dev/null 2>>$ERR
                swapon $MNT/swapfile >/dev/null 2>>$ERR
                check_errors || return 1
            else
                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then
                    ttl=" $_PrepMntPart " msg="\nmkswap $PART\n\n"
                    if dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
                        mkswap "$PART" >/dev/null 2>$ERR
                    else
                        return
                    fi
                fi
                swapon "$PART" >/dev/null 2>>$ERR
                check_errors || return 1
                PARTS="$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS" | sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PART}$' -'~~)"
                ((NUM--))
            fi
        fi
    }

    MOUNT=""
    local ttl msg
    ttl=" $_PrepMntPart "
    msg="$_WarnMount1 '$_Skip' $_WarnMount2"
    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 0 0
    lvm_detect
    INC_PART='part\|lvm\|crypt'
    umount_parts
    find_parts || return 1
    msg="$_SelRootBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    ROOT_PART="$(cat $ANS)"
    choose_fs
    mnt || return 1
    swap

    # efi partition
    if [[ $SYSTEM == "UEFI" ]]; then
        msg="$_SelUefiBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || return 1
        PART="$(cat $ANS)"
        EFI_PART="$(cat $ANS)"
        if grep -q 'fat' <<< "$(fsck -N "$PART")"; then
            msg="$_FormUefiBody $PART $_FormUefiBody2"
            if ! dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
                mkfs.vfat -F32 "$PART" >/dev/null 2>$ERR
            fi
        else
            mkfs.vfat -F32 "$PART" >/dev/null 2>$ERR
        fi
        mkdir -p $MNT/$EFI_MNT
        mount $PART $MNT/$EFI_MNT 2>>$ERR
        check_errors && confirm_mount "$MNT/$EFI_MNT" || return 1
    fi

    # remaining partitions
    while (( NUM > 0 )); do
        msg="$_ExtPartBody"
        ttl=" $_PrepMntPart "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 "$_Done" "-" $PARTS 2>$ANS || { break; return 1; }
        PART="$(cat $ANS)"
        if [[ $PART == "$_Done" ]]; then
            break; return 0
        else
            MOUNT=""
            choose_fs
            [[ $SYSTEM == "UEFI" ]] && MNT_EXAMPLES="/home /var" || MNT_EXAMPLES="/boot /home /var"
            ttl=" $_PrepMntPart $PARTITON "
            msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || { break; return 1; }
            MOUNT="$(cat $ANS)"
            while [[ ${MOUNT:0:1} != "/" || ${#MOUNT} -le 1 || $MOUNT =~ \ |\' ]]; do
                msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || { break; break; return 0; }
                MOUNT="$(cat $ANS)"
            done
            mnt || return 1
            if [[ $MOUNT == "/usr" ]]; then
                ! grep -q "usr" <<< "$HOOKS" && HOOKS="usr $HOOKS"
            elif [[ $MOUNT == "/boot" ]]; then
                grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")" && SBOOT=2 || SBOOT=1
            fi
            ((NUM--))
        fi
    done
}

######################################################################
##               Encryption (dm_crypt) Functions                    ##
######################################################################

luks_password() {
    local msg="$_LuksPassBody"
    local msg2="$_PassNUsrBody2 $LUKS_ROOT_NAME"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --insecure --passwordbox "$msg" 10 40 2>$ANS || return 1
    PASSWD="$(cat $ANS)"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --insecure --passwordbox "$msg2" 8 40 2>$ANS || return 1
    PASSWD2="$(cat $ANS)"
    if [[ $PASSWD != "$PASSWD2" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 10 40
        luks_password
    fi
    LUKS_PASSWD="$PASSWD"
    return 0
}

luks_open() {
    local ttl msg def
    LUKS_ROOT_NAME=""
    INC_PART='part\|crypt\|lvm'
    umount_parts
    find_parts
    ttl=" $_LuksOpen " msg="$_LuksMenuBody" def="cryptroot"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 10 50 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    msg="$_LuksOpenBody"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 50 "$def" 2>$ANS || return 1
    LUKS_ROOT_NAME="$(cat $ANS)"
    if luks_password; then
        msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
        dialog --backtitle "$BT" --title " $_LuksOpen " --infobox "$msg" 10 50
        echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>$ERR
        check_errors || return 1
        luks_show
    fi
}

luks_setup() {
    local def msg ttl
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umount_parts
    find_parts
    ttl=" $_LuksEncrypt "
    msg="$_LuksEncryptBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 12 50 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    msg="$_LuksOpenBody"
    def="cryptroot"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 12 50 "$def" 2>$ANS || return 1
    LUKS_ROOT_NAME="$(cat $ANS)"
    luks_password || return 1
}

luks_default() {
    if luks_setup; then
        local msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
        dialog --backtitle "$BT" --title " $_LuksEncrypt " --infobox "$msg" 0 0
        echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>$ERR
        echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
        check_errors || return 1
        luks_show
    fi
}

luks_key() {
    local msg ttl def
    if luks_setup; then
        msg="$_LuksCipherKey"
        ttl=" $_PrepLUKS "
        def="-s 512 -c aes-xts-plain64"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "$def" 2>$ANS || return 1
        msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
        dialog --backtitle "$BT" --title " $_LuksEncryptAdv " --infobox "$msg" 0 0
        echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>$ERR
        echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
        check_errors || return 1
        luks_show
    fi
}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local msg="${_LuksMenuBody}${_LuksMenuBody2}${_LuksMenuBody3}"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --menu "$msg" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2> $ANS || return
    case "$(cat $ANS)" in
        "$_LuksOpen") luks_open ;;
        "$_LuksEncrypt") luks_default ;;
        "$_LuksEncryptAdv") luks_key ;;
        *) return
    esac
    luks_menu
}

######################################################################
##               Logical Volume Management Functions                ##
######################################################################

lvm_detect() {
    LVM_PV="$(pvs -o pv_name --noheading 2>/dev/null)"
    LV_VG="$(vgs -o vg_name --noheading 2>/dev/null)"
    LV="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
    if [[ $LV && $LV_VG && $LVM_PV ]]; then
        dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>$ERR
        check_errors || return 1
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    local msg ttl
    VG_LIST=""
    list="$(lvs --noheadings | awk '{print $2}' | uniq)"
    for i in $list; do
        size="$(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')"
        VG_LIST="$VG_LIST $i $size"
    done
    if [[ -z $VG_LIST ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        return 1
    fi
    ttl=" $_PrepLVM "
    msg="$_LvmSelVGBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 5 $VG_LIST 2>$ANS || return 1
    return 0
}

lvm_create() {
    check_lv_size() {
        local lv="$((${#LV_SIZE} - 1))"
        (( ${#LV_SIZE} == 0 || ${LV_SIZE:0:1} == 0 )) && ERR_SIZE=1 || ERR_SIZE=0
        if (( ERR_SIZE == 0 )); then
            for (( i=0; i<lv; i++ )); do
                [[ ${LV_SIZE:$i:1} != [0-9] ]] && ERR_SIZE=1 && break
            done
        fi
        if (( ERR_SIZE == 0 )); then
            LV_SIZE_TYPE=${LV_SIZE:$lv:1}
            case $LV_SIZE_TYPE in
                m|M|g|G) ERR_SIZE=0 ;;
                *) ERR_SIZE=1
            esac
        fi
        if (( ERR_SIZE == 0 )); then
            s=${LV_SIZE:0:$lv}
            case $LV_SIZE_TYPE in
                G|g) [[ $((s * 1000)) -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - $((s * 1000)))) ;;
                M|m) [[ ${LV_SIZE:0:$lv} -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - s)) ;;
                *) ERR_SIZE=1
            esac
        fi
    }

    LV_VG="" VG_PARTS="" VG_MB=0 INC_PART='part\|crypt'
    umount_parts
    find_parts
    PARTS="$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")"
    local msg="$_LvmNameVgBody"
    local ttl=" $_LvmCreateVG "
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || return 1
    LV_VG="$(cat $ANS)"
    while [[ ${LV_VG:0:1} == "/" || ${#LV_VG} -eq 0 || $LV_VG =~ \ |\' || $(grep -q "$LV_VG" <<< "$(lsblk)") ]]; do
        dialog --backtitle "$BT" --title "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; return; }
        LV_VG="$(cat $ANS)"
    done
    msg="$_LvmPvSelBody $_UseSpaceBar"
    dialog --backtitle "$BT" --title "$ttl" --checklist "$msg" 0 0 7 $PARTS 2>$ANS
    [[ $(cat $ANS) != "" ]] && VG_PARTS="$(cat $ANS)" || return 1
    msg="${_LvmPvConfBody1}: ${LV_VG}\n\n$_LvmPvConfBody2${VG_PARTS}"

    dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0 || return 1
    msg="$_LvmPvActBody1${LV_VG}.\n$_PlsWaitBody"
    dialog --backtitle "$BT" --title "$ttl" --infobox "$msg" 10 50
    sleep 1 && vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>$ERR
    check_errors || return 1
    VG_SIZE="$(vgdisplay "$LV_VG" | grep 'VG Size' | sed 's/\..*//' | sed 's/[^0-9]*//g')"
    SIZE_TYPE="$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')"
    [[ ${SIZE_TYPE:0:1} == "G" ]] && VG_MB=$((VG_SIZE * 1000)) || VG_MB=$VG_SIZE
    msg="${_LvmPvDoneBody1}'$LV_VG' $_LvmPvDoneBody2\n\n($VG_SIZE $SIZE_TYPE)"
    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 8 50
    msg="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dialog --backtitle "$BT" --title "$ttl" --radiolist "$msg" 0 0 9 \
        "1" "-" off "2" "-" off "3" "-" off  "4" "-" off \
        "5" "-" off "6" "-" off "7" "-" off "8" "-" off "9" "-" off 2>$ANS
    [[ $(cat $ANS) != "" ]] && NUM_LVS=$(cat $ANS) || return 1
    while (( NUM_LVS > 1 )); do
        ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
        msg="$_LvmLvNameBody1"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; return 1; }
        LV_NAME="$(cat $ANS)"
        while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $(grep -q "$LV_NAME" <<< "$(lsblk)") ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; break; return 1; }
            LV_NAME="$(cat $ANS)"
        done
        msg="${LV_VG}: ${VG_SIZE}$SIZE_TYPE (${VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; return 1; }
        LV_SIZE="$(cat $ANS)"
        check_lv_size
        while (( ERR_SIZE == 1 )); do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; break; return 1; }
            LV_SIZE="$(cat $ANS)"
            check_lv_size
        done
        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>$ERR
        check_errors || return 1
        msg="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 0 0
        ((NUM_LVS--))
    done
    ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
    msg="$_LvmLvNameBody1 $_LvmLvNameBody2 (${VG_MB}MB)."
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || return 1
    LV_NAME="$(cat $ANS)"
    while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $(grep -q "$LV_NAME" <<< "$(lsblk)") ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; return 1; }
        LV_NAME="$(cat $ANS)"
    done
    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>$ERR
    check_errors || return 1
    ((NUM_LVS--))
    LVM=1
    ttl=" $_LvmCreateVG "
    msg="$_LvmCompBody"
    dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0 && show_devices || return 1
    return 0
}

lvm_del_vg() {
    lvm_show_vg
    if dialog --backtitle "$BT" --title " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    return
}

lvm_del_all() {
    LVM_PV="$(pvs -o pv_name --noheading 2>/dev/null)"
    LV_VG="$(vgs -o vg_name --noheading 2>/dev/null)"
    LV="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
    if dialog --backtitle "$BT" --title " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
        LVM=0
    fi
    return 0
}

lvm_menu() {
    dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "\nDetecting LVM's.\n$_PlsWaitBody" 0 0
    sleep 1 && lvm_detect
    dialog --backtitle "$BT" --title " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2>$ANS || return 1
    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create ;;
        "$_LvmDelVG") lvm_del_vg ;;
        "$_LvMDelAll") lvm_del_all ;;
        *) return 1
    esac
    lvm_menu
}

######################################################################
##                      Installation Functions                      ##
######################################################################

install_system() {
    if ! [[ $UNPCK ]]; then
        local ttl="Begin System Unpacking"
        local msg="This will unpack $DIST to the partition chosen during mounting:\n$ROOT_PART"
        if [[ $SYSTEM == "UEFI" ]]; then
            msg="$msg\n\nThe bootloader will be written to the system EFI partition:\n$EFI_PART"
        else
            msg="$msg\n\nBIOS (legacy boot) systems can install the bootloader on any available partition.\n\nDuring unpacking you'll be asked which partition to use.\n\nThe recommended and simple approach is to choose the root (/) partition:\n$ROOT_PART"
        fi
        msg="$msg\n\nDo you want to continue?"
        dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0 && unpack_image || return 1
    fi
    clear
    genfstab -U -p $MNT >$MNT/etc/fstab 2>$ERR
    check_errors || return 1
    [[ -f $MNT/swapfile ]] && sed -i "s/\\${MNT}//" $MNT/etc/fstab
    run_mkinitcpio || return 1
    install_boot || return 1
    config_menu || edit_configs
}

unpack_image() {
    clear && echo -e "\nUnpacking the system\n$_PlsWaitBody\n\n"
    rsync -a --info=progress2 /run/archiso/sfs/airootfs/ $MNT/ 2>$ERR
    check_errors || return 1
    local autostart files menu openb
    openb="$MNT/home/$LUSER/.config/openbox"
    menu="$openb/menu.xml"
    autostart="$openb/autostart"
    files=(etc/sudoers.d/g_wheel etc/mkinitcpio-archiso.conf usr/bin/install-al
    usr/bin/al-installer etc/polkit-1/rules.d/49-nopasswd_global.rules
    home/$LUSER/.config/keypack home/$LUSER/bin/welcome.sh)
    for f in "${files[@]}"; do
        [[ -e $MNT/$f ]] && rm -rf $MNT/$f
    done
    find $MNT/usr/lib/initcpio -name "archiso*" -type f -exec rm '{}' \;

    sed -i '/keypack/d' $autostart
    sed -i '/welcome.sh/d' $autostart
    sed -i 's/#$HOME/$HOME/g' $autostart
    sed -i '/installer/ { N; N; d; }' $openb/rc.xml
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $autostart
    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $autostart
    sed -i '/item label="W e l c o m e"/ i\    <separator label="A r c h L a b s"/>' $menu
    sed -i '/item label="W e l c o m e"/ { N; N; N; N; N; N; N; N; N; N; N; d; }' $menu

    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf
    cp -f /run/archiso/bootmnt/arch/boot/x86_64/vmlinuz $MNT/boot/vmlinuz-linux
    cp -f /tmp/keyboard $MNT/etc/default/
    cp -f /tmp/vconsole.conf $MNT/etc/
    cp -f /tmp/01-keyboard.conf $MNT/etc/X11/xorg.conf.d/
    cp -f /etc/resolv.conf $MNT/etc/
    cp -rf /etc/NetworkManager/system-connections $MNT/etc/NetworkManager/
    clear && echo -e "\nOptimizing Mirrorlist\n$_PlsWaitBody\n\n"
    reflector --score 40 --fastest 10 --sort rate --save $MNT/etc/pacman.d/mirrorlist
    chr "pacman -Syyu --color always --noconfirm" 2>$ERR
    chr "pacman -S iputils --color always --noconfirm" 2>$ERR
    chr "pacman -S base-devel git --color always --needed --noconfirm" 2>$ERR
    UNPCK="True"
}

install_boot() {
    grub_configuration() {
        local CFG="$MNT/etc/default/grub"
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $CFG
        if (( LUKS == 1 )); then
            if [[ $LUKS_DEV ]]; then
                sed -i "s~GRUB_CMDLINE_LINUX=\"\"~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $CFG 2>$ERR
                check_errors || return 1
            fi
            sed -i "s/#GRUB_ENABLE_CRYPTODISK=y/GRUB_ENABLE_CRYPTODISK=y/g" $CFG 2>$ERR
            check_errors || return 1
        fi
        if [[ $SYSTEM == "BIOS" ]]; then
            if (( LVM == 1 && SBOOT == 0 )) || (( SBOOT == 2 )); then
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $CFG 2>$ERR
                check_errors || return 1
            fi
        fi
    }

    bios_bootloader() {
        select_device "grub" || return 1
        local msg="\nInstalling bootloader to: ${DEVICE}\n${_PlsWaitBody}"
        dialog --backtitle "$BT" --title "$_InstBootldr" --infobox "$msg" 0 0
        chr "grub-install --bootloader-id=$DIST --recheck --force $DEVICE" 2>$ERR
        check_errors || return 1
        grub_configuration || return 1
    }

    uefi_bootloader() {
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars &>/dev/null
            chr "mount -t efivarfs efivarfs /sys/firmware/efi/efivars" &>/dev/null
        fi
        chr "grub-install --bootloader-id=$DIST --recheck --force" 2>$ERR
        check_errors || return 1
        grub_configuration || return 1
        local bd drs
        bd="Boot"
        drs="$(find "$MNT/$EFI_MNT/EFI" -maxdepth 1 -mindepth 1 -type d)"
        for i in $drs; do
            n="$(basename "$i")"
            grep -qi "boot" <<< "$n" && { bd="$n"; break; }
        done
        mkdir -p "$MNT/$EFI_MNT/EFI/$bd"
        chr "cp -fa /$EFI_MNT/EFI/$DIST/grubx64.efi /$EFI_MNT/EFI/$bd/grubx64.efi"
        chr "cp -fa /$EFI_MNT/EFI/$bd/grubx64.efi /$EFI_MNT/EFI/$bd/bootx64.efi"
    }

    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl"
    if ! [[ $BOOTD ]]; then
        mkdir -p $MNT/run/udev && mount -o bind /run/udev $MNT/run/udev
        if [[ $SYSTEM == "BIOS" ]]; then
            bios_bootloader || return 1
        else
            uefi_bootloader || return 1
        fi
        BOOTD="True"
    fi
    chr "os-prober" &>/dev/null
    chr "grub-mkconfig -o /boot/grub/grub.cfg" 2>$ERR
    check_errors || return 1
    msg="\nBootloader install complete"
    [[ $SYSTEM == "BIOS" ]] && dialog --backtitle "$BT" --title " $_InstBootldr " --msgbox "$msg" 0 0
}

run_mkinitcpio() {
    clear
    local conf="$MNT/etc/mkinitcpio.conf"
    if (( LVM == 1 && LUKS == 0 )); then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $conf 2>$ERR
    elif (( LVM == 1 && LUKS == 1 )); then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $conf 2>$ERR
    elif (( LVM == 0 && LUKS == 1 )); then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>$ERR
    fi
    check_errors || return 1
    if [[ $LUKS_PASSWD && $LUKS_UUID ]]; then
        local dev
        dev="$(lsblk -lno NAME,UUID,TYPE | grep "part")"
        dev="/dev/$(grep "$LUKS_UUID" <<< "$dev" | awk '{print $1}')"
        chr "dd bs=512 count=8 if=/dev/urandom of=/crypto_keyfile.bin"
        chr "chmod 000 /crypto_keyfile.bin"
        chr "echo '$LUKS_PASSWD' | cryptsetup luksAddKey $dev /crypto_keyfile.bin"
        sed -i 's/FILES=()/FILES=(\/crypto_keyfile.bin)/g' $conf
    fi
    sed -i "s/keyboard fsck/keyboard ${HOOKS} fsck/g" $conf
    chr "mkinitcpio -p linux" 2>$ERR
    check_errors || return 1
}

######################################################################
##                          Menu Interfaces                         ##
######################################################################

main_menu() {
    if [[ $MENU == "prep" && $HL -eq 7 && -z $UNPCK ]]; then
        MH=3
        MENU="main"
        # when returning from prep, bail from install if we aren't ready yet
        ([[ -z $ROOT_PART ]] || [[ $SYSTEM == "UEFI" && -z $EFI_PART ]]) && return 0
        check_mount && install_system
        return 0
    elif [[ ! -e $MNT/etc && $MENU != "main" ]]; then
        MH=1
        MENU="main"
    elif (( MH < 5 )); then
        ((MH++))
    fi
    dialog --backtitle "$BT" --title " $_MMTitle " --default-item $MH --menu "$_MMBody" 18 60 5 \
        "1" "$_PrepMenuTitle" \
        "2" "$_InstBseMenuTitle" \
        "3" "$_ConfBseMenuTitle" \
        "4" "$_SeeConfOptTitle" \
        "5" "$_Done" 2>$ANS
    MH=$(cat $ANS)
    if [[ ! -z $MH ]]; then
        if (( MH == 2 )) && ! check_mount; then
            return 1
        elif (( MH >= 3 && MH <= 4 )) && ! (check_mount && check_base); then
            return 1
        fi
    fi
    case $MH in
        1) prep_menu ;;
        2) install_system ;;
        3) config_menu ;;
        4) edit_configs ;;
        *) dialog --backtitle "$BT" --yesno "$_CloseInstBody" 8 45 && { umount_parts; clear; exit 0; } || return 0
    esac
    return 0
}

prep_menu() {
    if [[ $MENU != "prep" ]]; then
        HL=1
        MENU="prep"
    elif (( HL < 7 )); then
        ((HL++))
        if (( HL == 7 )) && [[ ! -z $ROOT_PART ]]; then
            # return to main menu and begin install if everything is set
            if [[ $SYSTEM == "UEFI" && ! -z $EFI_PART ]] || [[ $SYSTEM != "UEFI" ]]; then
                return 0
            fi
        fi
    fi
    dialog --backtitle "$BT" --title " $_PrepMenuTitle " --default-item $HL \
        --menu "$_PrepMenuBody" 15 60 7 \
        "1" "$_PrepKBLayout" \
        "2" "$_DevShowOpt" \
        "3" "$_PrepPartDisk" \
        "4" "$_PrepLUKS" \
        "5" "$_PrepLVM" \
        "6" "$_PrepMntPart" \
        "7" "$_Back" 2>$ANS
    HL="$(cat $ANS)"
    case $HL in
        1) set_keymap ;;
        2) show_devices ;;
        3) umount_parts && select_device && create_parts ;;
        4) luks_menu ;;
        5) lvm_menu ;;
        6) mount_parts ;;
        *) return 0
    esac
    prep_menu
}

config_menu() {
    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl"
    if [[ $MENU != "config" ]]; then
        HL=1
        MENU="config"
    elif (( HL < 5 )); then
        ((HL++))
    fi
    local ttl=" $_ConfBseMenuTitle "
    dialog --backtitle "$BT" --title "$ttl" --default-item $HL --menu "$_ConfBseBody" 13 50 5 \
        "1" "$_ConfBseHost" \
        "2" "$_ConfBseSysLoc" \
        "3" "$_ConfUsrRoot" \
        "4" "$_ConfUsrNew" \
        "5" "$_Back" 2>$ANS
    HL=$(cat $ANS)
    case $HL in
        1) set_hostname ;;
        2) set_locale ;;
        3) root_password ;;
        4) create_user || return 1 ;;
        *) return 0
    esac
    config_menu
}

edit_configs() {
    if [[ $MENU != "edit" ]]; then
        HL=1
        MENU="edit"
    elif (( HL < 11 )); then
        ((HL++))
    fi
    dialog --backtitle "$BT" --title " $_SeeConfOptTitle " --default-item $HL \
        --menu "$_SeeConfOptBody" 19 60 11 \
        "1" "keymap configs" \
        "2" "locale configs" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/pacman.conf" \
        "11" "$_Back" 2>$ANS
    HL=$(cat $ANS)
    FILE=""
    xkeyfile="$MNT/etc/X11/xorg.conf.d/01-keyboard.conf"
    case $HL in
        1) [[ -e $xkeyfile ]] && FILE="$FILE $xkeyfile"
            [[ -e $MNT/etc/vconsole.conf ]] && FILE="$MNT/etc/vconsole.conf"
            [[ -e $MNT/etc/default/keyboard ]] && FILE="$FILE $MNT/etc/default/keyboard" ;;
        2) [[ -e $MNT/etc/locale.conf ]] && FILE="$MNT/etc/locale.conf"
            [[ -e $MNT/etc/default/locale ]] && FILE="$FILE $MNT/etc/default/locale" ;;
        3) [[ -e $MNT/etc/hostname ]] && FILE="$MNT/etc/hostname" ;;
        4) [[ -e $MNT/etc/hosts ]] && FILE="$MNT/etc/hosts" ;;
        5) [[ -e $MNT/etc/sudoers ]] && FILE="$MNT/etc/sudoers" ;;
        6) [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        7) [[ -e $MNT/etc/fstab ]] && FILE="$MNT/etc/fstab" ;;
        8) [[ -e $MNT/etc/crypttab ]] && FILE="$MNT/etc/crypttab" ;;
        9) [[ -e $MNT/etc/default/grub ]] && FILE="$MNT/etc/default/grub" ;;
        10) [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) return 0
    esac
    if [[ $FILE ]]; then
        ([[ $DISPLAY ]] && hash geany &>/dev/null) && geany -i $FILE || vim -O $FILE
    else
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
    fi
    edit_configs
}

[[ $1 == "--debug" || $1 == "-d" ]] && debug_log
select_lang
check_req
id_system
dialog --backtitle "$BT" --title " $_WelTitle $VER " --msgbox "$_WelBody" 0 0
MH=0 HL=0
while true; do
    main_menu
done

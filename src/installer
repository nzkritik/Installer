#!/usr/bin/env bash

# vim:ft=sh:fdm=marker:fmr={,}

# Originally Written by Carl Duff for PacBang Linux
# Heavily modified by Nathaniel Maia for use in Archlabs
# This program is free software, provided under the GNU GPL

readonly LUSER="liveuser"    # Live user
readonly DIST="Archlabs"     # Distributor
readonly VER="1.4.12"        # Version
readonly MNT="/mnt/install"  # Mountpoint
readonly ANS="/tmp/answer"   # Stores answers
readonly MOPTS="/tmp/mopts"  # Mount options
readonly ERR="/tmp/errlog"   # Error logging
readonly LOG="/tmp/log"      # set -x logging
readonly EFI="boot/efi"      # EFI mountpoint

VG_MB=0             # Remaining VG MB
SBOOT=0             # Separate /boot
HOOKS="shutdown"    # Init hooks


# geolocation timezone used for automatic setup
GEOLC="$(curl --silent freegeoip.net/xml/)"
GEOLC="${GEOLC#*<TimeZone>}"
GEOLC="${GEOLC%</TimeZone>*}"

# timezones used for manual setup if automatic fails
TZONES="$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab |
    grep ".*/.*" |
    sort -ud)"

for i in $(awk -F/ '{print $1}' <<< "$TZONES"); do
    ZONES="$ZONES $i -"
done

# parsed locales from /etc/locale.gen
LOCALES="$(grep -v "# " /etc/locale.gen |
    sed 's/#//g' |
    sed 's/ UTF-8//g' |
    grep .UTF-8)"

for i in $LOCALES; do
    LCLS="$LCLS $i -"
done

# parsed console maps from /usr/share/kbd/keymaps
CMAPS="$(ls -R /usr/share/kbd/keymaps |
    grep "map.gz" |
    sed 's/\.map\.gz//g' |
    sort)"

for i in $CMAPS; do
    CMAP="$CMAP $i -"
done

# array of keymaps for use with xorg
XMAPS=('af' 'al' 'am' 'at' 'az' 'ba' 'bd' 'be' 'bg' 'br' 'bt' 'bw' 'by' 'ca'
'cd' 'ch' 'cm' 'cn' 'cz' 'de' 'dk' 'ee' 'es' 'et' 'eu' 'fi' 'fo' 'fr' 'gb' 'ge'
'gh' 'gn' 'gr' 'hr' 'hu' 'ie' 'il' 'in' 'iq' 'ir' 'is' 'it' 'jp' 'ke' 'kg' 'kh'
'kr' 'kz' 'la' 'lk' 'lt' 'lv' 'ma' 'md' 'me' 'mk' 'ml' 'mm' 'mn' 'mt' 'mv' 'ng'
'nl' 'no' 'np' 'pc' 'ph' 'pk' 'pl' 'pt' 'ro' 'rs' 'ru' 'se' 'si' 'sk' 'sn' 'sy'
'tg' 'th' 'tj' 'tm' 'tr' 'tw' 'tz' 'ua' 'us' 'uz' 'vn' 'za')

for i in "${XMAPS[@]}"; do
    XMAP="$XMAP $i -"
done

######################################################################
##                  Utility and Check Functions                     ##
######################################################################

chr() {
    arch-chroot $MNT /bin/bash -c "$1"
}

dbg() {
    echo "" >$LOG
    set -x
    exec 3>| $LOG
    BASH_XTRACEFD=3
    ( termite --exec="tail -f $LOG" & )
}

clean() {
    [[ -e $ANS ]] && rm -rf $ANS
    [[ -e $MOPTS ]] && rm -rf $MOPTS
    [[ -e $ERR ]] && rm -rf $ERR
    [[ -e $LOG ]] && rm -rf $LOG
    return 0
}

getpass() {
    dialog --backtitle "$BT" --title " $1 " --insecure --passwordbox "$2" 10 40 2>$ANS || return 1
}

msgbox() {
    dialog --backtitle "$BT" --title " $1 " --msgbox "$2" $3 $4
}

lang() {
    dialog --backtitle "$BT" --title " Select Language " --menu \
        "Language - sprache - taal - språk - lingua - idioma - nyelv - língua" 20 60 10 \
        "1" "English            (en_**)" \
        "2" "Español            (es_ES)" \
        "3" "Português [Brasil] (pt_BR)" \
        "4" "Português          (pt_PT)" \
        "5" "Français           (fr_FR)" \
        "6" "Russkiy            (ru_RU)" \
        "7" "Italiano           (it_IT)" \
        "8" "Nederlands         (nl_NL)" \
        "9" "Magyar             (hu_HU)" \
        "10" "Chinese            (zh_CN)" 2> $ANS

    case "$(cat $ANS)" in
        1) source ../trans/english.trans && LOC="en_US.UTF-8" ;;
        2) source ../trans/spanish.trans && LOC="es_ES.UTF-8" ;;
        3) source ../trans/p_brasil.trans && LOC="pt_BR.UTF-8" ;;
        4) source ../trans/portuguese.trans && LOC="pt_PT.UTF-8" ;;
        5) source ../trans/french.trans && LOC="fr_FR.UTF-8" ;;
        6) source ../trans/russian.trans && LOC="ru_RU.UTF-8" ;;
        7) source ../trans/italian.trans && LOC="it_IT.UTF-8" ;;
        8) source ../trans/dutch.trans && LOC="nl_NL.UTF-8" ;;
        9) source ../trans/hungarian.trans && LOC="hu_HU.UTF-8" ;;
        10) source ../trans/chinese.trans && LOC="zh_CN.UTF-8" ;;
        *) clear && exit 0
    esac

    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
    [[ $LOC != "en_US.UTF-8" ]] && sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen

    locale-gen &>/dev/null

    export LANG="$LOC"
}

req_chk() {
    local msg cur_user
    cur_user="$(whoami)"
    if [[ $cur_user != "root" ]] || ! ping -c 1 www.github.com &>/dev/null; then

        [[ $cur_user != "root" ]] && msg="${_NotRoot}$_Exit" || msg="$_NoNetwork"

        dialog --backtitle "$DIST Installer - (x86_64)" --title " $_ErrTitle " --infobox "$msg" 0 0
        sleep 3
        exit 1
    fi
    echo "" > $ERR
}

id_sys() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi

    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYS="UEFI"
    else
        SYS="BIOS"
    fi

    readonly BT="$DIST Installer - $SYS (x86_64)"
}

err_chk() {
    if (( $? == 1 )) && grep -wqi "${errmsg:-error}" "$ERR"; then
        local msg
        # clean escape sequences from the error message
        msg="$(sed 's/[^[:print:]]//g' "$ERR" |
            sed 's/\[[0-9\;:]*\?m//g' |
            sed 's/==> //g' |
            sed 's/] ERROR:/]\nERROR:/g')"

        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$msg" 0 0

        msg="An error was encountered during install\n\n'Yes' to keep install"
        msg="$msg intact and fix manually\n'No' to wipe install (preserves /boot)"
        if ! dialog --backtitle "$BT" --title " $_ErrTitle " --yesno "$msg" 9 55; then
            for d in $MNT/?*; do
                if ! grep -q "boot" <<< "$d"; then
                    rm -rf "$d"
                fi
            done
        fi
        echo "" >$ERR # wipe error log
        return 1
    fi
    return 0
}

mnt_chk() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        return 1
    fi
    return 0
}

base_chk() {
    if [[ ! -e $MNT/etc ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        return 1
    fi
    return 0
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT |
        grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dialog --backtitle "$BT" --title " $_PrepShowDev " --textbox /tmp/.devlist 0 0
}

######################################################################
##                  System Settings Functions                       ##
######################################################################

set_keymap() {
    console_keymap() {
        local msg ttl map
        msg="$_CMapBody"
        ttl=" $_CMapTitle "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 22 60 16 $CMAP 2>$ANS || return 1
        map="$(cat $ANS)"
        map=${map:-us}

        echo "KEYMAP=$map" >/tmp/vconsole.conf
    }

    xorg_keymap() {
        local msg ttl map
        msg="$_XMapBody"
        ttl=" $_PrepLayout "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 22 60 16 $XMAP 2>$ANS || return 1
        map="$(sed 's/_.*//' $ANS)"
        map="${map:-us}"
        setxkbmap "$map" 2>$ERR
        err_chk || return 1

        cat >/tmp/01-keyboard.conf <<EOF
Section "InputClass"
    Identifier "system-keyboard"
    MatchIsKeyboard "on"
    Option "XkbLayout" "$map"
EndSection
EOF
        cat >/tmp/keyboard <<EOF
# KEYBOARD CONFIGURATION FILE
# Consult the keyboard(5) manual page.

XKBMODEL=""
XKBLAYOUT="$map"
XKBVARIANT=""
XKBOPTIONS=""
BACKSPACE="guess"
EOF
    }

    console_keymap && xorg_keymap || return 1
}

set_locale() {
    local ttl=" $_ConfLocale "
    dialog --backtitle "$BT" --title "$ttl" --menu "$_LocaleBody" 20 60 12 $LCLS 2>$ANS || return
    loc="$(cat $ANS)"

    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/locale.conf

    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale

    sed -i "s/#en_US.UTF-8/en_US.UTF-8/g" $MNT/etc/locale.gen

    sed -i "s/#${loc}/${loc}/g" $MNT/etc/locale.gen

    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/default/locale

    dialog --backtitle "$BT" --title "$ttl" --infobox "\nGenerating locale: $loc\n$_PlsWait" 0 0
    chr "locale-gen" >/dev/null 2>$ERR
    err_chk || return 1
    set_timezone
}

set_timezone() {
    local zone sub local ttl msg
    if [[ -z $manual ]]; then
        # automatic timezone setting with geoip
        if grep -q "$GEOLC" <<< "$TZONES"; then
            zone="${GEOLC%/*}"
            sub="${GEOLC#*/}"
        fi
    else
        # manual timezone
        ttl=" $_ConfTimeHC "
        msg="$_TimeZBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 20 45 10 $ZONES 2>$ANS || return
        zone="$(cat $ANS)"
        SUB=$(grep "$zone" <<< "$TZONES" | awk -F/ '{print $2}' | sort -ud)

        for i in $SUB; do
            SUBS="$SUBS $i -"
        done

        msg="$_TimeSubZBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 20 45 11 $SUBS 2>$ANS || return
        sub="$(cat $ANS)"
    fi

    # if both zone and sub are set we ask confirmation and set it
    # if not set or user rejects it, we revert to manual selection
    if [[ ! -z $zone && ! -z $sub ]]; then
        ttl=" $_ConfTimeHC "
        msg="$_TimeZQ $zone/$sub?\n\n"
        if dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
            chr "ln -sf /usr/share/zoneinfo/$zone/$sub /etc/localtime" 2>$ERR
            err_chk || return 1
        else
            manual="True"
            set_timezone
        fi
    else
        manual="True"
        set_timezone
    fi

    # step done and continue to set hwclock
    SETT="True"
    set_hw_clock
}

set_hw_clock() {
    # try setting the default setting for hwclock
    chr "hwclock --systohc --utc"
    if (( $? == 1 )); then
        # when errors occur attempt handling them with a fallback
        chr "hwclock --systohc --utc --directisa" 2>$ERR
        if (( $? == 1 )) && grep -wqi "error" "$ERR"; then
            # if still failing, alert the user and just continue
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$(cat "$ERR")" 0 0
            echo "" >$ERR
        fi
    fi
}

set_hostname() {
    local host ttl msg
    ttl=" $_ConfHost "
    msg="$_HostNameBody"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 14 60 "${DIST,,}" 2>$ANS || return 1
    host="$(cat $ANS)"

    echo "$host" >$MNT/etc/hostname

    cat > $MNT/etc/hosts << EOF
127.0.0.1   localhost
127.0.1.1   $host
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF
}

root_password() {
    local ttl=" $_ConfRoot "
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$_RootBody" 10 40 2>$ANS || return 1
    PASSWD="$(cat $ANS)"
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$_RootBody2" 10 40 2>$ANS || return 1
    PASSWD2="$(cat $ANS)"
    if [[ "$PASSWD" == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        chr "passwd root" </tmp/.passwd >/dev/null 2>$ERR
        err_chk || return 1
        rm -f /tmp/.passwd
        RPASS="True"
        return 0
    fi
    dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "${_PassErr}$_TryAgain" 0 0
    root_password
}

create_user() {
    dialog --backtitle "$BT" --title " $_UserTitle " --inputbox "$_UserBody" 11 40 "" 2>$ANS || return 1
    usr="$(cat $ANS)"
    while [[ ${#usr} -eq 0 || $usr =~ \ |\' || $usr =~ [^a-z0-9\ ] ]]; do
        dialog --backtitle "$BT" --title " $_UserTitle " --inputbox "$_UserErrBody" 10 40 "" 2>$ANS || { break; return 1; }
        usr="$(cat $ANS)"
    done

    local msg1="$_UserPass $usr"
    local msg2="$_UserPass2 $usr"
    local ttl=" $_ConfUser "
    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg1" 10 40 2>$ANS || return 1
    PASSWD="$(cat $ANS)"

    dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg2" 10 40 2>$ANS || return 1
    PASSWD2="$(cat $ANS)"

    while [[ "$PASSWD" != "$PASSWD2" ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "${_PassErr}$_TryAgain" 8 60
        dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg1" 10 40 2>$ANS || { break; return 1; }
        PASSWD="$(cat $ANS)"
        dialog --backtitle "$BT" --title "$ttl" --insecure --passwordbox "$msg2" 10 40 2>$ANS || { break; return 1; }
        PASSWD2="$(cat $ANS)"
    done

    dialog --backtitle "$BT" --title "$ttl" --infobox "$_UserSetBody" 0 0
    sleep 2 && echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
    local group="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"

    # If the first user account, change the live account
    if [[ -e $MNT/home/$LUSER ]]; then
        chr "passwd $LUSER" </tmp/.passwd >/dev/null 2>$ERR
        err_chk || return 1
        local files wheel autostart
        wheel="%wheel ALL=(ALL) ALL"
        autostart="home/$LUSER/.config/openbox/autostart"
        files=(etc/systemd/system/autologin@.service $autostart etc/group etc/gshadow etc/passwd etc/shadow)
        for f in "${files[@]}"; do sed -i "s/${LUSER}/${usr}/g" "$MNT/$f"; done
        chr "mv /home/$LUSER /home/$usr" 2>$ERR
        chr "chown -R $usr:users /home/$usr" 2>>$ERR
        chr "usermod -aG $group $usr" 2>>$ERR
        sed -i "s/# ${wheel}/${wheel}/g" $MNT/etc/sudoers
    else
        chr "useradd $usr -m -g users -G $group -s /bin/zsh" 2>$ERR
        chr "passwd $usr" < /tmp/.passwd >/dev/null 2>>$ERR
        chr "cp -R /etc/skel/ /home/$usr" 2>>$ERR
        chr "chown -R ${usr}:users /home/$usr" 2>>$ERR
    fi
    err_chk || return 1

    [[ -e /tmp/.passwd ]] && rm /tmp/.passwd
    [[ -z $UNPK || -z $SETT || -z $RPASS || -z $BOOTD ]] && return 0
    ttl="Installation Finished"
    msg="The install is now complete\n\nWould you like to close the installer and reboot\n\nSelect 'No' to make additional changes to the system"
    dialog --backtitle "$BT" --title " $ttl " --yesno "$msg" 0 0 && { umnt_pts; reboot; } || return 1
}

######################################################################
##                System and Partitioning Functions                 ##
######################################################################

umnt_pts() {
    MOUNTED="$(mount | grep "$MNT" | awk '{print $3}' | sort -r)"
    swapoff -a
    for i in $MOUNTED; do
        umount -r "$i" >/dev/null 2>$ERR
        err_chk || return 1
    done
}

conf_mnt() {
    local ttl msg
    ttl=" $_MntTitle "

    if grep -q "$1" <<< "$(mount)"; then
        dialog --backtitle "$BT" --title "$ttl" --infobox "$_MntSucc" 0 0
        sleep 2

        PARTS="$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS" |
            sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" |
            sed s~${PART}$' -'~~)"

        ((NUM--))
        return 0
    fi

    dialog --backtitle "$BT" --title "$ttl" --infobox "$_MntFail" 0 0
    sleep 2
    return 1
}

sel_dev() {
    local msg
    [[ $1 == "grub" ]] && msg="$_DevSelTitle for Bootloader\n\n$_DevSelBody" || msg="$_DevSelBody"

    DEVICE=""
    DEVS="$(lsblk -lno NAME,SIZE,TYPE |
        grep 'disk' |
        awk '{print "/dev/" $1 " " $2}' |
        sort -u)"

    dialog --backtitle "$BT" --title " $_DevSelTitle " --menu "$msg" 0 0 4 $DEVS 2>$ANS || return 1

    [[ $(cat $ANS) != "" ]] && DEVICE="$(cat $ANS)" || return 1
}

find_pts() {
    NUM=0
    PARTS="$(lsblk -lno NAME,SIZE,TYPE |
        grep "$INC_PART" |
        sed 's/part$/\/dev\//g' |
        sed 's/lvm$\|crypt$/\/dev\/mapper\//g' |
        awk '{print $3$1 " " $2}' |
        sort -u)"

    for i in $PARTS; do
        ((NUM++));
    done

    NUM=$((NUM / 2)) # due to storing the device size, we need half the number of fields

    case "$INC_PART" in
        'part\|lvm\|crypt') ([[ $NUM -eq 0 ]] || [[$SYS == "UEFI" && $NUM -lt 2 ]]) && ERRMSG="$_PartErrBody" ;;
        'part\|crypt') (( NUM == 0 )) && ERRMSG="$_LvmPartErrBody" ;;
        'part\|lvm') (( NUM < 2 )) && ERRMSG="$_LuksPartErrBody"
    esac

    if [[ $ERRMSG ]]; then
        local ttl=" $_ErrTitle "
        dialog --backtitle "$BT" --title "$ttl" --msgbox "$ERRMSG" 0 0
        sel_dev && mk_pts || return 1
    fi

    return 0
}

mk_pts() {
    swipe() {
        local msg="$_PartBody1 $DEVICE $_PartBody2 $_PartBody3"
        if dialog --backtitle "$BT" --title " $_PartWipe " --yesno "$msg" 0 0; then
            clear
            echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            mk_pts
        fi
    }

    auto_pt() {
        if [[ $SYS == "BIOS" ]]; then
            _PartBody2="will be destroyed.\n\nAn ext4 partition will be created using all available space."
        fi
        local msg="$_PartBody1 $DEVICE $_PartBody2 $_PartBody3"
        if dialog --backtitle "$BT" --title " $_PrepParts " --yesno "$msg" 0 0; then

            dp="$(parted -s "$DEVICE" print |
                awk '/^ / {print $1}' |
                sort -r)"

            for p in $dp; do
                parted -s "$DEVICE" rm $p 2>$ERR
                err_chk || { break; return 1; }
            done

            table="$(parted -s "$DEVICE" print |
                grep -i 'partition table' |
                awk '{print $3}')"

            if [[ $SYS == "BIOS" && $table != "msdos" ]]; then
                parted -s "$DEVICE" mklabel msdos 2>$ERR
            elif [[ $SYS == "UEFI" && $table != "gpt" ]]; then
                parted -s "$DEVICE" mklabel gpt 2>$ERR
            fi

            err_chk || return 1

            if [[ $SYS == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 100% 2>$ERR
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>$ERR
                parted -s "$DEVICE" set 1 boot on 2>>$ERR
                parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>$ERR
            fi

            err_chk || return 1

            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist

            dialog --backtitle "$BT" --title "" --textbox /tmp/.devlist 0 0
        fi
    }

    dialog --backtitle "$BT" --title "$_PartTitle" --menu "$_PartBody" 0 0 5 \
        "$_PartWipe" "BIOS & UEFI" \
        "$_PartAuto" "BIOS & UEFI" \
        "gparted"    "BIOS & UEFI" \
        "cfdisk"     "BIOS/MBR" \
        "parted"     "UEFI/GPT" 2>$ANS

    RET="$(cat $ANS)"

    [[ -z $RET ]] && return 1

    if [[ $RET != "$_PartWipe" && $RET != "$_PartAuto" ]]; then
        $RET "$DEVICE"
    elif [[ $RET == "$_PartWipe" ]]; then
        swipe && mk_pts
    else
        auto_pt
    fi

    return 0
}

sel_fs() {
    FS_OPTS=()
    dialog --backtitle "$BT" --title " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_Skip"   "-" \
        "ext4"     "mkfs.ext4 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext2"     "mkfs.ext2 -q" \
        "btrfs"    "mkfs.btrfs -f" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2>$ANS

    select="$(cat $ANS)"

    case $select in
        "$_Skip") FS="$_Skip" ;;
        ext4) FS="mkfs.ext4 -q" FS_OPTS=(dealloc discard noacl noatime nobarrier nodelalloc) ;;
        ext3) FS="mkfs.ext3 -q" ;;
        ext2) FS="mkfs.ext2 -q" ;;
        btrfs) FS="mkfs.btrfs -f"
            FS_OPTS=(autodefrag "compress=zlib" "compress=lzo"
            "compress=no" "compress-force=zlib" "compress-force=lzo"
            discard noacl noatime nodatasum nospace_cache recovery
            skip_balance space_cache ssd ssd_spread)
            modprobe btrfs
            ;;
        f2fs) FS="mkfs.f2fs"
            FS_OPTS=(data_flush disable_roll_forward disable_ext_identify
            discard fastboot flush_merge inline_xattr inline_data inline_dentry
            no_heap noacl nobarrier noextent_cache noinline_data norecovery)
            modprobe f2fs
            ;;
        jfs) FS="mkfs.jfs -q" FS_OPTS=(discard "errors=continue" "errors=panic" nointegrity) ;;
        nilfs2) FS="mkfs.nilfs2 -q"
            FS_OPTS=(discard nobarrier "errors=continue" "errors=panic" "order=relaxed" "order=strict" norecovery)
            ;;
        ntfs) FS="mkfs.ntfs -q" ;;
        reiserfs) FS="mkfs.reiserfs -q" FS_OPTS=(acl nolog notail replayonly user_xattr) ;;
        vfat) FS="mkfs.vfat -F32" ;;
        xfs) FS="mkfs.xfs -f"
            FS_OPTS=(discard filestreams ikeep largeio noalign nobarrier norecovery noquota wsync)
            ;;
        *) return 1
    esac

    if [[ $FS != "$_Skip" ]]; then
        local msg="\nFormat $PART as $select?\n\n"

        if dialog --backtitle "$BT" --title " $_FSTitle " --yesno "$msg" 0 0; then

            msg="\nFormatting $PART as $select.\n$_PlsWait"
            dialog --backtitle "$BT" --title " $_FSTitle " --infobox "$msg" 0 0

            sleep 1
            $FS $PART >/dev/null 2>$ERR
            err_chk || return 1
        else
            sel_fs
        fi
    fi
}

mnt_pts() {
    opts() {
        OPTS=""
        echo "" >$MOPTS
        local ttl msg

        for i in "${FS_OPTS[@]}"; do
            OPTS="$OPTS $i - off"
        done

        ttl=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "

        dialog --backtitle "$BT" --title "$ttl" --checklist "$_MntBody" 0 0 ${#FS_OPTS[@]} $OPTS 2>$MOPTS || return

        sed -i 's/ /,/g' $MOPTS
        sed -i '$s/,$//' $MOPTS

        MOUNT_OPTS="$(cat $MOPTS)"

        if [[ $MOUNT_OPTS ]]; then
            msg="${_MntConfBody}$MOUNT_OPTS\n"
            ttl=" $_MntTitle "
            dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 10 50 && return 0 || opts
        fi
    }

    mnt() {
        local op b blk
        mkdir -p "${MNT}$MOUNT"
        (( ${#FS_OPTS[@]} > 0 )) && opts
        op="$(cat $MOPTS)"
        if [[ $op ]]; then
            mount -o $op "$PART" "${MNT}$MOUNT" 2>$ERR
        else
            mount "$PART" "${MNT}$MOUNT" 2>$ERR
        fi
        err_chk && conf_mnt "${MNT}$MOUNT" || return 1

        b="$(lsblk -lno NAME,FSTYPE,TYPE)"

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        if grep -qi "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then

            LUKS=1
            LUKS_NAME="$(sed "s~^/dev/mapper/~~g" <<< "$PART")"

            blk="$(grep "lvm" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/mapper/"$1}' <<< "$blk" | uniq)"

            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME"
                    LVM=1
                    break
                fi
            done

            blk="$(grep "part" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/"$1}' <<< "$blk" | uniq)"

            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID="$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")"
                    LUKS_UUID="$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')"
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    break
                fi
            done

        elif grep -qi "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
            LVM=1
            LV_NAME="$(sed "s~^/dev/mapper/~~g" <<< "$PART")"

            blk="$(grep "crypt" <<< "$b" | grep -i "lvm2_member")"
            crypt="$(awk '{print "/dev/mapper/"$1}' <<< "$blk" | uniq)"

            for i in $crypt; do
                if grep -q "$LV_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME="$(sed 's~/dev/mapper/~~g' <<< "$i")"
                    break
                fi
            done

            blk="$(grep "part" <<< "$b" | grep -i "crypto_luks")"
            crypt="$(awk '{print "/dev/"$1}' <<< "$blk" | uniq)"

            for i in $crypt; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID="$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")"
                    LUKS_UUID="$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')"
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    LUKS=1
                    break
                fi
            done
        fi
    }

    swap() {
        local a ttl msg mem tot

        mem="$(grep MemTotal /proc/meminfo |
            awk '{print $2/1024}' |
            sed 's/\..*//')"

        dialog --backtitle "$BT" --title " $_PrepMount " --menu "$_SelSwpBody" 0 0 7 \
            "$_Skip" "-" \
            "$_SelSwpFile" "${mem}M" \
            $PARTS 2>$ANS || return 1

        a="$(cat $ANS)"

        if [[ $a && $a != "$_Skip" ]]; then
            if [[ $a == "$_SelSwpFile" ]]; then
                local ttl msg
                ttl=" $_SelSwpFile "
                msg="Enter size for swapfile below\n\nM = MB, G = GB"
                dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2>$ANS || return 0
                tot="$(cat $ANS)"

                while ! [[ ${tot: -1} =~ [MG] ]]; do
                    msg="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 7 40
                    msg="\nM = MB, G = GB\n"
                    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2>$ANS || { break; return 0; }
                    tot="$(cat $ANS)"
                done

                fallocate -l "$tot" $MNT/swapfile 2>$ERR
                chmod 600 $MNT/swapfile 2>>$ERR
                mkswap $MNT/swapfile >/dev/null 2>>$ERR
                swapon $MNT/swapfile >/dev/null 2>>$ERR

                err_chk || return 1
            else
                PART="$(cat $ANS)"

                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then

                    ttl=" $_PrepMount " msg="\nmkswap $PART\n\n"
                    if dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
                        mkswap "$PART" >/dev/null 2>$ERR
                    else
                        return
                    fi
                fi

                swapon "$PART" >/dev/null 2>>$ERR
                err_chk || return 1

                PARTS="$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS" |
                    sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" |
                    sed s~${PART}$' -'~~)"

                ((NUM--))
            fi
        fi
    }

    MOUNT=""
    local ttl msg
    ttl=" $_PrepMount "
    msg="$_WarnMount1 '$_Skip' $_WarnMount2"
    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 0 0
    lvm_detect
    INC_PART='part\|lvm\|crypt'
    umnt_pts
    find_pts || return 1
    msg="$_SelRootBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    ROOT_PT="$(cat $ANS)"
    sel_fs
    mnt || return 1
    swap

    # efi partition
    if [[ $SYS == "UEFI" ]]; then
        msg="$_SelUefiBody"
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || return 1
        EFI_PT="$(cat $ANS)"

        if grep -q 'fat' <<< "$(fsck -N "$EFI_PT")"; then
            msg="$_FormUefiBody $PART $_FormUefiBody2"
            if ! dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0; then
                mkfs.vfat -F32 "$EFI_PT" >/dev/null 2>$ERR
            fi
        else
            mkfs.vfat -F32 "$EFI_PT" >/dev/null 2>$ERR
        fi
        mkdir -p $MNT/$EFI
        mount $EFI_PT $MNT/$EFI 2>>$ERR
        err_chk && conf_mnt "$MNT/$EFI" || return 1
    fi

    # remaining partitions
    while (( NUM > 0 )); do
        msg="$_ExtPartBody"
        ttl=" $_PrepMount "
        dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 7 \
            "$_Done" "-" \
            $PARTS 2>$ANS || { break; return 1; }

        PART="$(cat $ANS)"

        if [[ $PART == "$_Done" ]]; then
            break
            return 0
        else

            MOUNT=""
            sel_fs
            [[ $SYS == "UEFI" ]] && MNT_EXAMPLES="/home /var" || MNT_EXAMPLES="/boot /home /var"

            ttl=" $_PrepMount $PARTITON "
            msg="${_ExtPartBody1}$MNT_EXAMPLES\n"

            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || { break; return 1; }
            MOUNT="$(cat $ANS)"

            while [[ ${MOUNT:0:1} != "/" || ${#MOUNT} -le 1 || $MOUNT =~ \ |\' ]]; do
                msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || { break; break; return 0; }
                MOUNT="$(cat $ANS)"
            done

            mnt || return 1

            if [[ $MOUNT == "/usr" ]]; then
                ! grep -q "usr" <<< "$HOOKS" && HOOKS="usr $HOOKS"
            elif [[ $MOUNT == "/boot" ]]; then
                grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")" && SBOOT=2 || SBOOT=1
            fi

            ((NUM--))
        fi
    done
}

######################################################################
##               Encryption (dm_crypt) Functions                    ##
######################################################################

luks_pass() {
    local msg="$_LuksPassBody"
    local msg2="$_UserBody2 $LUKS_ROOT_NAME"
    getpass "$_PrepLUKS" "$msg" || return 1
    PASSWD="$(cat $ANS)"
    getpass "$_PrepLUKS" "$msg2" || return 1
    PASSWD2="$(cat $ANS)"
    if [[ $PASSWD != "$PASSWD2" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "${_PassErr}$_TryAgain" 10 40
        luks_pass
    fi
    LUKS_PASSWD="$PASSWD"
    return 0
}

luks_open() {
    local ttl msg def
    LUKS_ROOT_NAME=""
    INC_PART='part\|crypt\|lvm'
    umnt_pts
    find_pts
    ttl=" $_LuksOpen " msg="$_LuksMenuBody" def="cryptroot"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 10 50 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    msg="$_LuksOpenBody"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 10 50 "$def" 2>$ANS || return 1
    LUKS_ROOT_NAME="$(cat $ANS)"
    if luks_pass; then
        msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
        dialog --backtitle "$BT" --title " $_LuksOpen " --infobox "$msg" 10 50
        echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>$ERR
        err_chk || return 1
        luks_show
    fi
}

luks_setup() {
    local def msg ttl
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umnt_pts
    find_pts
    ttl=" $_LuksEncrypt "
    msg="$_LuksEncryptBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 12 50 7 $PARTS 2>$ANS || return 1
    PART="$(cat $ANS)"
    msg="$_LuksOpenBody"
    def="cryptroot"
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 12 50 "$def" 2>$ANS || return 1
    LUKS_ROOT_NAME="$(cat $ANS)"
    luks_pass || return 1
}

luks_default() {
    if luks_setup; then
        local msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
        dialog --backtitle "$BT" --title " $_LuksEncrypt " --infobox "$msg" 0 0
        echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>$ERR
        echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
        err_chk || return 1
        luks_show
    fi
}

luks_key() {
    local msg ttl def
    if luks_setup; then
        msg="$_LuksCipherKey"
        ttl=" $_PrepLUKS "
        def="-s 512 -c aes-xts-plain64"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "$def" 2>$ANS || return 1
        msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
        dialog --backtitle "$BT" --title " $_LuksEncryptAdv " --infobox "$msg" 0 0
        echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>$ERR
        echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
        err_chk || return 1
        luks_show
    fi
}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local msg="${_LuksMenuBody}${_LuksMenuBody2}${_LuksMenuBody3}"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --menu "$msg" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2> $ANS || return
    case "$(cat $ANS)" in
        "$_LuksOpen") luks_open ;;
        "$_LuksEncrypt") luks_default ;;
        "$_LuksEncryptAdv") luks_key ;;
        *) return
    esac
    luks_menu
}

######################################################################
##               Logical Volume Management Functions                ##
######################################################################

lvm_detect() {
    LVM_PV="$(pvs -o pv_name --noheading 2>/dev/null)"
    LV_VG="$(vgs -o vg_name --noheading 2>/dev/null)"
    LV="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
    if [[ $LV && $LV_VG && $LVM_PV ]]; then
        dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>$ERR
        err_chk || return 1
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    local msg ttl
    VG_LIST=""
    list="$(lvs --noheadings | awk '{print $2}' | uniq)"
    for i in $list; do
        size="$(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')"
        VG_LIST="$VG_LIST $i $size"
    done
    if [[ -z $VG_LIST ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        return 1
    fi
    ttl=" $_PrepLVM "
    msg="$_LvmSelVGBody"
    dialog --backtitle "$BT" --title "$ttl" --menu "$msg" 0 0 5 $VG_LIST 2>$ANS || return 1
    return 0
}

lvm_create() {
    chk_lv_size() {
        local lv="$((${#LV_SIZE} - 1))"
        (( ${#LV_SIZE} == 0 || ${LV_SIZE:0:1} == 0 )) && ERR_SIZE=1 || ERR_SIZE=0
        if (( ERR_SIZE == 0 )); then
            for (( i=0; i<lv; i++ )); do
                [[ ${LV_SIZE:$i:1} != [0-9] ]] && ERR_SIZE=1 && break
            done
        fi
        if (( ERR_SIZE == 0 )); then
            LV_SIZE_TYPE=${LV_SIZE:$lv:1}
            case $LV_SIZE_TYPE in
                m|M|g|G) ERR_SIZE=0 ;;
                *) ERR_SIZE=1
            esac
        fi
        if (( ERR_SIZE == 0 )); then
            s=${LV_SIZE:0:$lv}
            case $LV_SIZE_TYPE in
                G|g) [[ $((s * 1000)) -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - $((s * 1000)))) ;;
                M|m) [[ ${LV_SIZE:0:$lv} -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - s)) ;;
                *) ERR_SIZE=1
            esac
        fi
    }

    LV_VG=""
    VG_PARTS=""
    VG_MB=0
    INC_PART='part\|crypt'
    umnt_pts
    find_pts
    PARTS="$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")"
    local ttl=" $_LvmCreateVG "
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$_LvmNameVgBody" 0 0 "" 2>$ANS || return 1
    LV_VG="$(cat $ANS)"

    # bad answer
    while [[ ${LV_VG:0:1} == "/" || ${#LV_VG} -eq 0 || $LV_VG =~ \ |\' || $(grep -q "$LV_VG" <<< "$(lsblk)") ]]; do
        dialog --backtitle "$BT" --title "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; return; }
        LV_VG="$(cat $ANS)"
    done

    dialog --backtitle "$BT" --title "$ttl" --checklist "$_LvmPvSelBody" 0 0 7 $PARTS 2>$ANS
    [[ $(cat $ANS) != "" ]] && VG_PARTS="$(cat $ANS)" || return 1

    msg="${_LvmPvConfBody1}: ${LV_VG}\n\n$_LvmPvConfBody2${VG_PARTS}"
    dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0 || return 1

    msg="$_LvmPvActBody1${LV_VG}.\n$_PlsWait"
    dialog --backtitle "$BT" --title "$ttl" --infobox "$msg" 10 50
    sleep 1 && vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>$ERR
    err_chk || return 1

    VG_SIZE="$(vgdisplay "$LV_VG" | grep 'VG Size' | sed 's/\..*//' | sed 's/[^0-9]*//g')"
    SIZE_TYPE="$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')"
    [[ ${SIZE_TYPE:0:1} == "G" ]] && VG_MB=$((VG_SIZE * 1000)) || VG_MB=$VG_SIZE

    msg="${_LvmPvDoneBody1}'$LV_VG' $_LvmPvDoneBody2\n\n($VG_SIZE $SIZE_TYPE)"
    dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 8 50

    msg="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dialog --backtitle "$BT" --title "$ttl" --radiolist "$msg" 0 0 9 \
        "1" "-" off \
        "2" "-" off \
        "3" "-" off \
        "4" "-" off \
        "5" "-" off \
        "6" "-" off \
        "7" "-" off \
        "8" "-" off \
        "9" "-" off 2>$ANS
    [[ $(cat $ANS) != "" ]] && NUM_LVS=$(cat $ANS) || return 1

    # loop selected amount
    while (( NUM_LVS > 1 )); do
        ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
        msg="$_LvmLvNameBody1"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; return 1; }
        LV_NAME="$(cat $ANS)"

        # bad answer
        while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $(grep -q "$LV_NAME" <<< "$(lsblk)") ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; break; return 1; }
            LV_NAME="$(cat $ANS)"
        done

        msg="${LV_VG}: ${VG_SIZE}$SIZE_TYPE (${VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; return 1; }
        LV_SIZE="$(cat $ANS)"
        chk_lv_size

        # bad size
        while (( ERR_SIZE == 1 )); do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || { break; break; return 1; }
            LV_SIZE="$(cat $ANS)"
            chk_lv_size
        done

        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>$ERR
        err_chk || return 1

        msg="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dialog --backtitle "$BT" --title "$ttl" --msgbox "$msg" 0 0
        ((NUM_LVS--))
    done

    # last or only
    ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
    msg="$_LvmLvNameBody1 $_LvmLvNameBody2 (${VG_MB}MB)."
    dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || return 1
    LV_NAME="$(cat $ANS)"
    # bad answer
    while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $(grep -q "$LV_NAME" <<< "$(lsblk)") ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        dialog --backtitle "$BT" --title "$ttl" --inputbox "$msg" 0 0 "lvol" 2>$ANS || { break; return 1; }
        LV_NAME="$(cat $ANS)"
    done

    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>$ERR
    err_chk || return 1
    ((NUM_LVS--))

    LVM=1
    ttl=" $_LvmCreateVG "
    msg="$_LvmCompBody"
    dialog --backtitle "$BT" --title "$ttl" --yesno "$msg" 0 0 && show_devices || return 1
    return 0
}

lvm_del_vg() {
    lvm_show_vg
    if dialog --backtitle "$BT" --title " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    return 0
}

lvm_del_all() {
    LVM_PV="$(pvs -o pv_name --noheading 2>/dev/null)"
    LV_VG="$(vgs -o vg_name --noheading 2>/dev/null)"
    LV="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
    if dialog --backtitle "$BT" --title " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
        LVM=0
    fi
    return 0
}

lvm_menu() {
    dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "\nDetecting LVM's.\n$_PlsWait" 0 0
    sleep 1 && lvm_detect
    dialog --backtitle "$BT" --title " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2>$ANS || return 1
    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create ;;
        "$_LvmDelVG") lvm_del_vg ;;
        "$_LvMDelAll") lvm_del_all ;;
        *) return 1
    esac
    lvm_menu
}

######################################################################
##                      Installation Functions                      ##
######################################################################

install() {
    if ! [[ $UNPK ]]; then
        local msg="This will unpack $DIST to the partition chosen during mounting:\n$ROOT_PT"
        if [[ $SYS == "UEFI" ]]; then
            msg="$msg\n\nThe bootloader will be written to the system EFI partition:\n$EFI_PT"
        else
            msg="$msg\n\nBIOS (legacy boot) systems can install the bootloader on any available partition.\n\nDuring unpacking you'll be asked which partition to use.\n\nThe recommended and simple approach is to choose the root (/) partition:\n$ROOT_PT"
        fi
        msg="$msg\n\nDo you want to continue?"
        dialog --backtitle "$BT" --title " $_InstTitle " --yesno "$msg" 0 0 && unpack || return 1
    fi
    clear
    genfstab -U -p $MNT >$MNT/etc/fstab 2>$ERR
    err_chk || return 1
    [[ -f $MNT/swapfile ]] && sed -i "s/\\${MNT}//" $MNT/etc/fstab
    mkinit || return 1
    bootldr || return 1
    config || edit
}

unpack() {
    clear && echo -e "\nUnpacking the system\n$_PlsWait\n\n"
    rsync -a --info=progress2 /run/archiso/sfs/airootfs/ $MNT/ 2>$ERR
    err_chk || return 1
    local autostart files menu openb
    openb="$MNT/home/$LUSER/.config/openbox"
    menu="$openb/menu.xml"
    autostart="$openb/autostart"
    files=(etc/sudoers.d/g_wheel etc/mkinitcpio-archiso.conf usr/bin/install-al
    usr/bin/al-installer etc/polkit-1/rules.d/49-nopasswd_global.rules
    home/$LUSER/.config/keypack home/$LUSER/bin/welcome.sh)
    for f in "${files[@]}"; do
        [[ -e $MNT/$f ]] && rm -rf $MNT/$f
    done
    find $MNT/usr/lib/initcpio -name "archiso*" -type f -exec rm '{}' \;

    sed -i '/keypack/d' $autostart
    sed -i '/welcome.sh/d' $autostart
    sed -i 's/#$HOME/$HOME/g' $autostart
    sed -i '/installer/ { N; N; d; }' $openb/rc.xml
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $autostart
    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $autostart
    sed -i '/item label="W e l c o m e"/ i\    <separator label="A r c h L a b s"/>' $menu
    sed -i '/item label="W e l c o m e"/ { N; N; N; N; N; N; N; N; N; N; N; d; }' $menu

    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf
    cp -f /run/archiso/bootmnt/arch/boot/x86_64/vmlinuz $MNT/boot/vmlinuz-linux
    cp -f /tmp/keyboard $MNT/etc/default/
    cp -f /tmp/vconsole.conf $MNT/etc/
    cp -f /tmp/01-keyboard.conf $MNT/etc/X11/xorg.conf.d/
    cp -f /etc/resolv.conf $MNT/etc/
    cp -rf /etc/NetworkManager/system-connections $MNT/etc/NetworkManager/
    clear && echo -e "\nOptimizing Mirrorlist\n$_PlsWait\n\n"
    reflector --score 40 --fastest 10 --sort rate --save $MNT/etc/pacman.d/mirrorlist
    chr "pacman -Syu --color always --noconfirm" 2>$ERR
    chr "pacman -S iputils --color always --noconfirm" 2>$ERR
    chr "pacman -S base-devel git --color always --needed --noconfirm" 2>$ERR
    # chr "pacman -Rs archlabs-installer --color always --noconfirm" 2>$ERR
    UNPK="True"
}

bootldr() {
    cfg() {
        local CFG="$MNT/etc/default/grub"
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $CFG
        if (( LUKS == 1 )); then
            if [[ $LUKS_DEV ]]; then
                sed -i "s~GRUB_CMDLINE_LINUX=\"\"~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $CFG 2>$ERR
                err_chk || return 1
            fi
            sed -i "s/#GRUB_ENABLE_CRYPTODISK=y/GRUB_ENABLE_CRYPTODISK=y/g" $CFG 2>$ERR
            err_chk || return 1
        fi
        if [[ $SYS == "BIOS" ]]; then
            if (( LVM == 1 && SBOOT == 0 )) || (( SBOOT == 2 )); then
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $CFG 2>$ERR
                err_chk || return 1
            fi
        fi
    }

    bios() {
        sel_dev "grub" || return 1
        local msg="\nInstalling bootloader to: ${DEVICE}\n${_PlsWait}"
        dialog --backtitle "$BT" --title "$_BootLdr" --infobox "$msg" 0 0
        chr "grub-install --bootloader-id=$DIST --recheck --force $DEVICE" 2>$ERR
        err_chk || return 1
        cfg || return 1
    }

    uefi() {
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars &>/dev/null
            chr "mount -t efivarfs efivarfs /sys/firmware/efi/efivars" &>/dev/null
        fi
        chr "grub-install --bootloader-id=$DIST --recheck --force" 2>$ERR
        err_chk || return 1
        cfg || return 1

        local bd drs
        bd="Boot"
        drs=$(find "$MNT/$EFI/EFI" -maxdepth 1 -mindepth 1 -type d)
        for i in $drs; do
            grep -qi "boot" <<< "$(basename $i)" && bd="$(basename $i)" && break
        done
        mkdir -p $MNT/$EFI/EFI/$bd
        cp -fa $MNT/$EFI/EFI/$DIST/grubx64.efi $MNT/$EFI/EFI/$bd/grubx64.efi
        cp -fa $MNT/$EFI/EFI/$bd/grubx64.efi $MNT/$EFI/EFI/$bd/bootx64.efi
    }

    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl"
    if ! [[ $BOOTD ]]; then
        mkdir -p $MNT/run/udev && mount -o bind /run/udev $MNT/run/udev
        if [[ $SYS != "UEFI" ]]; then
            bios || return 1
        else
            uefi || return 1
        fi
        BOOTD="True"
    fi
    chr "os-prober" &>/dev/null
    chr "grub-mkconfig -o /boot/grub/grub.cfg" 2>$ERR
    err_chk || return 1
    if [[ $SYS != "UEFI" ]]; then
        msg="\nBootloader install complete\n\n"
        dialog --backtitle "$BT" --title " $_BootLdr " --msgbox "$msg" 0 0
    fi
}

mkinit() {
    clear
    local conf="$MNT/etc/mkinitcpio.conf"
    if (( LVM == 1 && LUKS == 0 )); then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $conf 2>$ERR
    elif (( LVM == 1 && LUKS == 1 )); then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $conf 2>$ERR
    elif (( LVM == 0 && LUKS == 1 )); then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>$ERR
    fi
    err_chk || return 1
    if [[ $LUKS_PASSWD && $LUKS_UUID ]]; then
        local dev
        dev="$(lsblk -lno NAME,UUID,TYPE | grep "part")"
        dev="/dev/$(grep "$LUKS_UUID" <<< "$dev" | awk '{print $1}')"
        chr "dd bs=512 count=8 if=/dev/urandom of=/crypto_keyfile.bin"
        chr "chmod 000 /crypto_keyfile.bin"
        chr "echo '$LUKS_PASSWD' | cryptsetup luksAddKey $dev /crypto_keyfile.bin"
        sed -i 's/FILES=()/FILES=(\/crypto_keyfile.bin)/g' $conf
    fi
    sed -i "s/keyboard fsck/keyboard ${HOOKS} fsck/g" $conf
    chr "mkinitcpio -p linux" 2>$ERR
    err_chk || return 1
}

######################################################################
##                          Menu Interfaces                         ##
######################################################################

main() {
    if [[ -z $PR ]]; then
        # automatically jump to prep menu on first run
        PR="True"
        prep
    elif [[ $MENU == "prepare" && $HL -eq 7 && -z $UNPK ]]; then
        # when returning from prep if everything is set, start the install
        MENU="main"
        if [[ -z $ROOT_PT ]] || [[ $SYS == "UEFI" && -z $EFI_PT ]]; then
            MH=0
            return 0
        fi
        mnt_chk && install
        MH=3
        return 0
    elif [[ -z $UNPK && $MENU != "main" ]]; then
        MH=1
        MENU="main"
    elif (( MH < 5 )); then
        ((MH++))  # highlight the next choice
    fi

    dialog --backtitle "$BT" --title " $_MainTitle " --default-item $MH \
        --menu "$_MainBody" 16 60 5 \
        "1" "$_PrepTitle" \
        "2" "$_InstTitle" \
        "3" "$_ConfTitle" \
        "4" "$_EditTitle" \
        "5" "$_Done" 2>$ANS

    MH=$(cat $ANS)

    if [[ -n $MH ]]; then
        if (( MH == 2 )) && ! mnt_chk; then
            return 1
        elif (( MH >= 3 && MH <= 4 )) && ! ( mnt_chk && base_chk ); then
            return 1
        fi
    fi

    case $MH in
        1) prep ;;
        2) install ;;
        3) config ;;
        4) edit ;;
        *)
            if dialog --backtitle "$BT" --yesno "$_CloseInstBody" 8 45; then
                umnt_pts
                clean
                clear
                exit 0
            fi
    esac

    return 0
}

prep() {
    # automatically jump to keymap assignment on first run
    if [[ -z $KM ]]; then
        HL=1
        KM="True"
        MENU="prepare"
        set_keymap
    elif [[ $MENU != "prepare" ]]; then # returning from another menu after first run
        HL=1
        MENU="prepare"
    elif (( HL < 7 )); then
        ((HL++))
        # return to main menu if finished in prep menu
        if [[ $HL -eq 7 && -n $ROOT_PT ]] && ( [[ $SYS == "UEFI" && -n $EFI_PT ]] || [[ $SYS != "UEFI" ]] ); then
            return 0
        fi
    fi
    dialog --backtitle "$BT" --title " $_PrepTitle " --default-item $HL \
        --menu "$_PrepBody" 15 60 7 \
        "1" "$_PrepLayout" \
        "2" "$_PrepShowDev" \
        "3" "$_PrepParts" \
        "4" "$_PrepLUKS" \
        "5" "$_PrepLVM" \
        "6" "$_PrepMount" \
        "7" "$_Back" 2>$ANS
    HL="$(cat $ANS)"
    case $HL in
        1) set_keymap ;;
        2) show_devices ;;
        3) umnt_pts && sel_dev && mk_pts ;;
        4) luks_menu ;;
        5) lvm_menu ;;
        6) mnt_pts ;;
        *) return 0
    esac
    prep
}

config() {
    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl"

    # run through each step automatically on first run
    if [[ -z $DN ]]; then
        HL=1
        DN="True"
        MENU="configure"
        set_hostname
        set_locale
        root_password
        create_user
    elif [[ $MENU != "configure" ]]; then # returning from another menu after first run
        HL=1
        MENU="configure"
    elif (( HL < 5 )); then
        ((HL++))  # highlight next option
    fi

    dialog --backtitle "$BT" --title " $_ConfTitle " --default-item $HL \
        --menu "$_ConfBody" 13 50 5 \
        "1" "$_ConfHost" \
        "2" "$_ConfLocale" \
        "3" "$_ConfRoot" \
        "4" "$_ConfUser" \
        "5" "$_Back" 2>$ANS

    HL=$(cat $ANS)

    case $HL in
        1) set_hostname ;;
        2) set_locale ;;
        3) root_password ;;
        4) create_user || return 1 ;; # if create_user returns 1, return to main
        *) return 0
    esac

    # recurse back
    config
}

edit() {
    if [[ $MENU != "edit" ]]; then
        HL=1
        MENU="edit"
    elif (( HL < 11 )); then
        ((HL++))
    fi
    dialog --backtitle "$BT" --title " $_EditTitle " --default-item $HL \
        --menu "$_EditBody" 19 60 11 \
        "1" "keymap configs" \
        "2" "locale configs" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/pacman.conf" \
        "11" "$_Back" 2>$ANS

    FILE=""
    HL="$(cat $ANS)"
    xkeyfile="$MNT/etc/X11/xorg.conf.d/01-keyboard.conf"

    case $HL in
        1) [[ -e $xkeyfile ]] && FILE="$FILE $xkeyfile"
           [[ -e $MNT/etc/vconsole.conf ]] && FILE="$MNT/etc/vconsole.conf"
           [[ -e $MNT/etc/default/keyboard ]] && FILE="$FILE $MNT/etc/default/keyboard" ;;
        2) [[ -e $MNT/etc/locale.conf ]] && FILE="$MNT/etc/locale.conf"
           [[ -e $MNT/etc/default/locale ]] && FILE="$FILE $MNT/etc/default/locale" ;;
        3) [[ -e $MNT/etc/hostname ]] && FILE="$MNT/etc/hostname" ;;
        4) [[ -e $MNT/etc/hosts ]] && FILE="$MNT/etc/hosts" ;;
        5) [[ -e $MNT/etc/sudoers ]] && FILE="$MNT/etc/sudoers" ;;
        6) [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        7) [[ -e $MNT/etc/fstab ]] && FILE="$MNT/etc/fstab" ;;
        8) [[ -e $MNT/etc/crypttab ]] && FILE="$MNT/etc/crypttab" ;;
        9) [[ -e $MNT/etc/default/grub ]] && FILE="$MNT/etc/default/grub" ;;
        10) [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) return 0
    esac

    if [[ $FILE ]]; then
        if [[ $DISPLAY ]] && hash geany &>/dev/null; then
            geany -i $FILE
        else
            vim -O $FILE
        fi
    else
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_NoFileErr" 0 0
    fi

    # recurse back after each file edit finishes
    edit
}

# enables set -x and logs xtrace, then opens a terminal running tail -f log
[[ $1 == "--debug" || $1 == "-d" ]] && dbg

# FIRST! set language and source translation files
lang

# SECOND! ensure run as root and with network connection
req_chk

# THIRD! id system, whether bios or uefi, checks for apple devices, sets the --backtitle used for dialogs
id_sys

# welcome message
dialog --backtitle "$BT" --title " $_WelTitle $VER " --msgbox "$_WelBody" 0 0
MH=0 HL=0

while true; do
    main
done
